<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Video</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="darkreader-lock" />
  <link rel="stylesheet" href="/theme.css" />
  <link rel="stylesheet" href="/app.css" />
</head>

<body>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%231d2a33'/%3E%3Cpath d='M24 18v28l24-14-24-14z' fill='%23fff'/%3E%3C/svg%3E" />
  <div id="app">
    <div id="videoWrap">
  <video id="player" preload="metadata" crossorigin="anonymous" playsinline>
        <p>Your browser does not support HTML5 video.</p>
      </video>
  <div id="ccOverlay" class="style-default">
      </div>
    </div>
    <aside id="chatPanel" class="">
      <div id="chatHeader">
  <div class="flex-row-gap6">
          <span>Chat</span>
        </div>
        <div id="chatUsers"></div>
      </div>
      <div id="chatMessages"></div>
  <form id="chatForm" autocomplete="off">
        <input id="chatInput" maxlength="300" placeholder="Send a message" />
        <div class="flex-row-gap6">
          <button id="chatSendBtn" type="submit">Send</button>
          <button id="nameBtn" type="button">Name</button>
        </div>
      </form>
    </aside>
    </div>
  <!-- chatExpand button removed; handled via control bar toggle -->
  <script src="/client-config.js"></script>
  <script>
  // Entry URLs:
  //  Viewer: /watchparty?key=YOURKEY (root '/' redirects here)
  //  Admin : /watchparty-admin?key=YOURKEY (older /admin path still accepted)
  const params = new URLSearchParams(location.search);
  // === Client function discovery instrumentation ===
  // Sends a one-time 'fn-log' message per function name when first invoked.
  const __fnSeen = new Set();
  function __logFnOnce(name){
    if(!name) return; if(__fnSeen.has(name)) return; __fnSeen.add(name);
    try { if(ws && ws.readyState===1){ ws.send(JSON.stringify({ type:'fn-log', name })); } } catch{}
  }
  // Wrapper helper: returns a wrapped version that logs once on first call.
  function __wrap(name, fn){ if(typeof fn!=='function') return fn; return function wrappedFn(){ __logFnOnce(name); return fn.apply(this, arguments); }; }
  // Later after definitions we will attempt to wrap selected globals (deferred until window load end).
  let ADMIN_KEY = params.get('key') || params.get('admin');
  let isAdmin = (location.pathname.startsWith('/watchparty-admin') || location.pathname.startsWith('/admin')) && !!ADMIN_KEY;
    const VERBOSE = params.has('verbose');
  if (isAdmin) { document.body.classList.add('is-admin'); }
  const video = document.getElementById('player');
  // IMPORTANT: Viewer must start muted for autoplay without user gesture (Chrome/Edge policy).
  // This line was removed earlier, causing NotAllowedError and blocked playback. Restored now.
  if(!isAdmin){
    video.muted = true; // runtime mute
    video.defaultMuted = true; // remember default
    try { video.setAttribute('muted',''); } catch {}
    // Add autoplay attribute to strengthen autoplay heuristics (some engines more lenient with both muted+autoplay present)
    try { video.setAttribute('autoplay',''); } catch {}
  }
  // Viewer & admin share same default audio behavior (no forced mute/unmute).
    const ccOverlay = document.getElementById('ccOverlay');
    // Always keep overlay as sibling of <video> inside wrapper so wrapper fullscreen includes it.
  let subTrackEl = null, subsEnabled = false, availableSubs = [], currentLang = null, currentStyle = null;
  let autoSubsAttempted = false;
    const STYLE_IDS = (window.WP_CLIENT_CONFIG && WP_CLIENT_CONFIG.styleIds) || ['default','outline','yellow','box'];
    const LANG_DISPLAY = (window.WP_CLIENT_CONFIG && WP_CLIENT_CONFIG.langDisplay) || {};
    function applyStyle(id) { if (!STYLE_IDS.includes(id)) id = 'default'; currentStyle = id; ccOverlay.classList.remove(...STYLE_IDS.map(s => 'style-' + s)); ccOverlay.classList.add('style-' + id); renderActiveCues(); }
    // Always start with default style (no persistence) after revert
    applyStyle('default');
    function clearOverlay() { ccOverlay.innerHTML = ''; }
    function renderActiveCues() { if (!subTrackEl || !subTrackEl.track || !subsEnabled) { clearOverlay(); return; } const cues = [...(subTrackEl.track.activeCues || [])]; if (!cues.length) { clearOverlay(); return; } ccOverlay.innerHTML = cues.map(c => `<div class='cc-bubble'>${(c.text || '').replace(/\n/g, '<br/>')}</div>`).join('<br/>'); layoutSubs(); }
    async function fetchSubsList() { try { const r = await fetch('/media/current-subs.json'); if (!r.ok) return []; const j = await r.json(); return j.tracks || []; } catch { return []; } }
    let subHeadInFlight = null;
    async function ensureSubTrack(specLang) {
      if (subTrackEl && specLang && specLang !== currentLang) { try { subTrackEl.remove(); } catch { } subTrackEl = null; }
      if (subTrackEl) return true;
      if (!availableSubs.length) { availableSubs = await fetchSubsList(); }
      if (!availableSubs.length) return false;
      let choose = null; if (specLang) choose = availableSubs.find(t => t.lang === specLang); if (!choose) choose = availableSubs.find(t => /^eng|en$/i.test(t.lang)) || availableSubs[0];
      currentLang = choose.lang;
      const qp = new URLSearchParams(); qp.set('rev', (lastState?.rev || 0)); qp.set('t', Date.now()); qp.set('lang', currentLang);
      // De-duplicate HEAD request so multiple concurrent enable attempts don't spam network.
      if(!subHeadInFlight){ subHeadInFlight = fetch('/media/current.vtt?' + qp.toString(), { method: 'HEAD' }); }
      let head; try { head = await subHeadInFlight; } finally { subHeadInFlight = null; }
      if (!head || !head.ok) return false;
      subTrackEl = document.createElement('track'); subTrackEl.kind = 'metadata'; subTrackEl.label = choose.label || choose.lang; subTrackEl.srclang = currentLang; subTrackEl.src = '/media/current.vtt?' + qp.toString();
      try { if (subTrackEl.track) subTrackEl.track.mode = 'hidden'; } catch {}
      video.appendChild(subTrackEl);
      setTimeout(() => { if (subTrackEl && subTrackEl.track) { try { subTrackEl.track.mode = 'hidden'; } catch {} subTrackEl.track.addEventListener('cuechange', () => { renderActiveCues(); }); renderActiveCues(); } }, 180);
      return true;
    }
    function refreshSubs() { if (subTrackEl) { try { subTrackEl.remove(); } catch { } } subTrackEl = null; subsEnabled = false; currentLang = null; availableSubs = []; clearOverlay(); }
    function layoutSubs() { // anchor & scale (fullscreen larger)
      ccOverlay.style.display = subsEnabled ? 'block' : 'none';
      const vw = video.videoWidth, vh = video.videoHeight, cw = video.clientWidth, ch = video.clientHeight; if (!vw || !vh) { ccOverlay.style.bottom = '6%'; ccOverlay.style.maxWidth = '90%'; return; }
      const scale = Math.min(cw / vw, ch / vh);
      const displayedHeight = vh * scale; const displayedWidth = vw * scale;
      const letterbox = (ch - displayedHeight) / 2;
      const fs = isFullscreen();
      const baseFontPx = Math.max(16, Math.min(fs ? 62 : 46, displayedHeight * (fs ? 0.055 : 0.045)));
      ccOverlay.style.fontSize = baseFontPx + 'px';
      const margin = Math.max(baseFontPx * 0.8, Math.min(fs ? 90 : 60, displayedHeight * (fs ? 0.08 : 0.055)));
      const bottomPx = letterbox + margin;
      ccOverlay.style.bottom = bottomPx + 'px';
      ccOverlay.style.maxWidth = Math.round(displayedWidth * (fs ? 0.92 : 0.88)) + 'px';
    }
    const videoWrap = document.getElementById('videoWrap');
    // Wipe animation state
    let wipeInProgress = false;
    function triggerWipeEnter(){
      if(!video) return;
      video.classList.remove('wipe-exit');
      // Prepare collapsed state BEFORE becoming visible
      video.classList.add('wipe-prep');
      video.style.display='block';
      video.style.visibility='visible';
      void video.offsetWidth; // ensure styles applied
      video.classList.remove('wipe-prep');
      void video.offsetWidth; // restart timeline after removing prep
      video.classList.add('wipe-enter');
  if (window.DEBUG_UI) console.log('[transition] wipe-enter start');
      wipeInProgress=true;
  setTimeout(()=>{ wipeInProgress=false; video.classList.remove('wipe-enter'); }, (WP_CLIENT_CONFIG?.transitions?.wipeDurationMs||1260) + (WP_CLIENT_CONFIG?.transitions?.wipeCleanupExtraMs||40)); // animation duration + buffer
    }
    function triggerWipeExit(cb){
      if(!video) { if(cb) cb(); return; }
      video.classList.remove('wipe-enter');
      // Ensure visible during collapse
      video.style.display='block';
      video.style.visibility='visible';
      void video.offsetWidth;
      video.classList.add('wipe-exit');
  if (window.DEBUG_UI) console.log('[transition] wipe-exit start');
      wipeInProgress=true;
  setTimeout(()=>{ wipeInProgress=false; video.classList.remove('wipe-exit'); if(cb) cb(); }, (WP_CLIENT_CONFIG?.transitions?.wipeDurationMs||1260) + (WP_CLIENT_CONFIG?.transitions?.wipeCleanupExtraMs||40)); // duration + buffer
    }
    // Starfield home screen (visible when no media loaded yet)
    const starCanvas = document.createElement('canvas');
    starCanvas.id = 'starfield';
  starCanvas.className = 'star-canvas';
    videoWrap.insertBefore(starCanvas, videoWrap.firstChild);
    const ctx = starCanvas.getContext('2d');
    let stars = []; let starAnimId = null; let lastStarTs = 0; let starfieldActive = false;
    function initStars() {
  const count = Math.min((WP_CLIENT_CONFIG?.starfield?.maxStars)||1600, Math.floor(starCanvas.width * starCanvas.height / ((WP_CLIENT_CONFIG?.starfield?.densityDivisor)||2200)));
      stars = Array.from({ length: count }, () => ({
        x: (Math.random() * 2 - 1), y: (Math.random() * 2 - 1), z: (Math.random()), pz: 1,
  speed: ((WP_CLIENT_CONFIG?.starfield?.speedMin)||0.000135) + Math.random() * ((WP_CLIENT_CONFIG?.starfield?.speedVar)||0.00036)
      }));
    }
    function resizeStars() { starCanvas.width = starCanvas.clientWidth; starCanvas.height = starCanvas.clientHeight; initStars(); }
    window.addEventListener('resize', resizeStars);
    resizeStars();
    function stepStars(ts) {
      if (!lastStarTs) lastStarTs = ts; const dt = Math.min(60, ts - lastStarTs); lastStarTs = ts;
      const w = starCanvas.width, h = starCanvas.height; const cx = w / 2, cy = h / 2;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
      for (const s of stars) {
  s.z -= s.speed * dt; if (s.z <= ((WP_CLIENT_CONFIG?.starfield?.recycleZ)||0.0005)) { s.x = (Math.random() * 2 - 1); s.y = (Math.random() * 2 - 1); s.z = 1; s.pz = 1; }
        const k = 1 / (s.z); const px = s.x * k * cx + cx; const py = s.y * k * cy + cy;
        if (px < 0 || px >= w || py < 0 || py >= h) { continue; }
        const r = Math.max(0.5, 1.8 * (1 - s.z));
        const alpha = Math.min(1, 1.2 * (1 - s.z));
        ctx.fillStyle = 'rgba(255,255,255,' + alpha.toFixed(3) + ')';
        ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI * 2); ctx.fill();
      }
      if (starfieldActive) starAnimId = requestAnimationFrame(stepStars);
    }
    function startStarfield() {
      if (starfieldActive) return; // already running
      starfieldActive = true;
      if (!starAnimId) starAnimId = requestAnimationFrame(stepStars);
      starCanvas.style.display = 'block';
      requestAnimationFrame(() => { starCanvas.style.opacity = '1'; });
  if (window.DEBUG_UI) console.log('[starfield] start');
    }
    function stopStarfield() {
      if (!starfieldActive) return; // already stopped
      starfieldActive = false;
      if (starAnimId) { cancelAnimationFrame(starAnimId); starAnimId = null; }
      starCanvas.style.opacity = '0';
  setTimeout(() => { if (!starfieldActive) starCanvas.style.display = 'none'; }, (WP_CLIENT_CONFIG?.starfield?.fadeOutMs)||520);
  if (window.DEBUG_UI) console.log('[starfield] stop');
    }
    // Start immediately on initial home screen
    startStarfield();
    // Home (no media) UI helpers
    let noMediaGlobal = true; // start with no media loaded
    let homeSelectEl = null;
  // Ensure viewer sees starfield immediately (hide empty video element until media provided)
  if(!isAdmin){ try { video.style.display='none'; } catch {} }
    function ensureHomeSelect() {
      if (homeSelectEl || !isAdmin) return;
      homeSelectEl = document.createElement('button');
      homeSelectEl.textContent = 'Select Media';
  homeSelectEl.className = 'home-start-btn';
  // Hover styling handled via CSS (.home-start-btn:hover). Removed JS background mutations.
      homeSelectEl.onclick = () => { if (window.openMediaPicker) window.openMediaPicker(); };
      videoWrap.appendChild(homeSelectEl);
    }
    // Media title pill (top-right, shows on hover alongside controls)
    const mediaTitle = document.createElement('div');
    mediaTitle.id = 'mediaTitle';
  mediaTitle.className = 'media-title';
    videoWrap.appendChild(mediaTitle);
    function friendlyTitle(path) { if (!path) return ''; const base = path.split(/[\\/]/).pop(); return base.replace(/\.(wp\.mp4|webm)$/i, ''); }
    function updateMediaTitle(path) { const t = friendlyTitle(path); mediaTitle.textContent = t || ''; }
    function isFullscreen() { return !!document.fullscreenElement; }
    document.addEventListener('fullscreenchange', () => { layoutSubs(); if (subsEnabled) renderActiveCues(); });
    // Chat related DOM refs moved earlier so control init can reference safely
    const chatPanel = document.getElementById('chatPanel');
    const chatMessages = document.getElementById('chatMessages');
    const chatUsersEl = document.getElementById('chatUsers');
    const chatForm = document.getElementById('chatForm');
    const chatInput = document.getElementById('chatInput');
    // Additional fullscreen listener added later once floating chat defined
    // Unified custom controls for both viewer & admin (admin gets extra play/pause + seek bar)
    (function initControls() {
      video.removeAttribute('controls');
      const ctr = document.createElement('div');
      ctr.id = 'customCtr';
  ctr.className = 'ctr-bar';
      function formatTime(sec) { if (!isFinite(sec)) return '0:00'; sec = Math.max(0, Math.floor(sec)); const h = Math.floor(sec / 3600); const m = Math.floor((sec % 3600) / 60); const s = sec % 60; const mm = (h ? m.toString().padStart(2, '0') : m); const ss = s.toString().padStart(2, '0'); return (h ? (h + ':') : '') + mm + ':' + ss; }
      function mkBtn(label, title) {
        const b = document.createElement('button');
        b.textContent = label; b.title = title || label;
  b.className = 'btn';
        b.onmouseenter = () => {
          if (b.dataset.active === '1') return; // keep active color
          b.style.background = '#333';
        };
        b.onmouseleave = () => {
          if (b.dataset.active === '1') return; // keep active color
          b.style.background = '#222';
        };
        return b;
      }
      // Admin extras: play/pause + seek bar
      let playBtn = null, seekWrap = null, seek = null, seekDragging = false;
      if (isAdmin) {
  playBtn = mkBtn('▶', 'Play/Pause');
  playBtn.classList.add('admin-only');
  // Large pill sizing via CSS class
  playBtn.classList.add('btn-large');
        function updatePlayBtn() { playBtn.textContent = video.paused ? '▶' : '⏸'; }
        playBtn.onclick = () => {
          // Prevent play attempts before media source assigned (was causing NotSupportedError after admin reload)
          if(!video.currentSrc){ telemetry && telemetry('admin.play.nosrc'); if(typeof showToast==='function') showToast('Media not loaded yet'); return; }
          const willPlay = video.paused;
          if (willPlay) { const p = video.play(); if(p && p.catch) p.catch(()=>{}); } else { video.pause(); }
          // Fallback broadcast: ensure a play/pause message gets out even if event handler missed
          setTimeout(()=>{ if(isAdmin && ws && ws.readyState===1){ const type = video.paused ? 'pause' : 'play'; send(type); } }, 60);
        };
        video.addEventListener('play', updatePlayBtn); video.addEventListener('pause', updatePlayBtn); updatePlayBtn();
  seekWrap = document.createElement('div'); seekWrap.className = 'admin-only cluster';
        seekWrap.onmouseenter = () => seekWrap.style.background = '#333';
        seekWrap.onmouseleave = () => seekWrap.style.background = '#222';
  seek = document.createElement('input'); seek.type = 'range'; seek.min = '0'; seek.max = '0'; seek.step = '0.01'; seek.value = '0'; seek.style.width = 'clamp(260px,35vw,640px)'; seek.style.cursor = 'pointer';
  // Wrap the range in its own relative container so tooltip alignment isn't skewed by outer padding/time label
  const seekTrackWrap = document.createElement('div'); seekTrackWrap.className='seek-track-wrap';
  seekTrackWrap.appendChild(seek);
  const timeLabel = document.createElement('span'); timeLabel.className = 'range-time'; timeLabel.textContent = '0:00 / 0:00';
  const seekPreview = document.createElement('div'); seekPreview.className = 'seek-tooltip'; seekPreview.textContent = '0:00';
  // Positioning adjustments: ensure tooltip bases off track width only
  seekPreview.style.pointerEvents='none';
  seekTrackWrap.appendChild(seekPreview);
        function updateTimeLabel() { timeLabel.textContent = formatTime(video.currentTime) + ' / ' + formatTime(video.duration || 0); }
        seek.addEventListener('mousedown', () => seekDragging = true);
        seek.addEventListener('touchstart', () => seekDragging = true, { passive: true });
        function commitSeek() { if (!isAdmin) return; suppress = true; video.currentTime = Number(seek.value); setTimeout(() => suppress = false, 120); // Include current paused state so viewers don't incorrectly resume
          send('seek', { paused: video.paused }); }
        ['mouseup', 'touchend', 'change'].forEach(ev => seek.addEventListener(ev, () => { if (seekDragging) { seekDragging = false; commitSeek(); } }));
        seek.addEventListener('input', () => { if (seekDragging) { /* preview only */ } });
        seek.addEventListener('mousemove', e => {
          if (!video.duration) return;
          const r = seek.getBoundingClientRect();
            let pct = (e.clientX - r.left) / r.width;
            if (!isFinite(pct)) pct = 0;
            pct = Math.min(1, Math.max(0, pct));
            const t = Math.min(video.duration, Math.max(0, video.duration * pct));
            seekPreview.textContent = formatTime(t);
            const pct100 = pct * 100;
            seekPreview.style.left = pct100 + '%';
            // Center by default; adjust only near edges
            let tx = -50;
            if (pct100 < 4) tx = -pct100; else if (pct100 > 96) tx = -(100 - pct100);
            seekPreview.style.transform = 'translate('+tx+'%, -6px)';
            seekPreview.style.opacity = '1';
        });
        seek.addEventListener('mouseleave', () => { seekPreview.style.opacity = '0'; });
  video.addEventListener('loadedmetadata', () => { seek.max = (video.duration || 0).toString(); updateTimeLabel(); telemetry('media.loadedmeta', {dur: video.duration||0, src: video.currentSrc||null}); });
  function updateSeekFill(){ if(seek && seek.max && Number(seek.max)>0){ const pct = (Number(seek.value)/Number(seek.max))*100; seek.style.setProperty('--pct', pct+'%'); } }
  video.addEventListener('timeupdate', () => { if (!seekDragging && video.duration) { seek.max = (video.duration || 0).toString(); seek.value = video.currentTime.toString(); updateSeekFill(); } if (!seekDragging) updateTimeLabel(); });
  seek.addEventListener('input', updateSeekFill);
  setTimeout(updateSeekFill, 60);
        setInterval(() => { if (isAdmin && !seekDragging) updateTimeLabel(); }, 1000);
  seekWrap.appendChild(seekTrackWrap);
        seekWrap.appendChild(timeLabel);
        // Reset UI when a different media file is loaded (invoked from applyState on rev change)
        function resetForNewMedia() {
          if (playBtn) { playBtn.textContent = '▶'; delete playBtn.dataset.active; playBtn.style.background = '#222'; }
          if (seek) { seek.value = '0'; seek.max = '0'; }
          if (timeLabel) { timeLabel.textContent = '0:00 / 0:00'; }
        }
        window.resetMediaUi = resetForNewMedia;
        ctr.appendChild(playBtn);
        ctr.appendChild(seekWrap);
        // Admin media selector button
    const mediaBtn = mkBtn('Media', 'Select media file');
    mediaBtn.classList.add('admin-only');
  mediaBtn.classList.add('btn-large');
        function openMediaPicker() {
          let existing = document.getElementById('mediaPicker'); if (existing) { existing.remove(); }
          const wrap = document.createElement('div'); wrap.id = 'mediaPicker'; wrap.className = 'media-picker-overlay';
          const box = document.createElement('div'); box.className = 'media-picker-box';
          box.innerHTML = '<div class="media-picker-header"><span class="title">Select Media</span><button id="mpHome" class="btn-chip">Home</button><button id="mpClose" class="btn-chip">Close</button></div>';
          const inner = document.createElement('div'); inner.className = 'media-picker-inner';
          const search = document.createElement('input'); search.type = 'text'; search.placeholder = 'Filter...'; search.className = 'input-filter';
          const status = document.createElement('div'); status.textContent = 'Loading...'; status.className = 'status-label';
          inner.appendChild(status);
          function shortName(rel) { return rel.split(/[\\/]/).pop(); }
          function highlightCurrent(el, rel) { if (lastState && lastState.path === rel) { el.style.background = '#2e78d2'; el.style.color = '#fff'; } }
          function baseEpisodeName(rel){
            // Derive human episode label from final component (file or manifest dir)
            const parts = rel.split(/\//);
            let last = parts[parts.length-1];
            if (last === 'manifest.json' && /\.wp\.chunks\/manifest\.json$/i.test(rel)) {
              // parent dir minus suffix
              const parent = parts[parts.length-2] || '';
              last = parent.replace(/\.wp\.chunks$/,'');
            } else {
              last = last.replace(/\.(wp\.mp4|webm)$/i,'');
            }
            return last;
          }
          function renderGrouped(list, activeTop){
            inner.innerHTML='';
            inner.appendChild(search);
            // Top-level pills (first segment)
            const topWrap = document.createElement('div'); topWrap.className='media-top-pills';
            const firstSegments = Array.from(new Set(list.map(p=> p.split('/')[0] || ''))).sort();
            function pill(label){
              const b=document.createElement('button'); b.type='button'; b.className='btn-chip'; b.textContent=label||'(root)';
              if(activeTop===label){ b.style.background='#2e78d2'; b.style.color='#fff'; }
              b.onclick=()=>{ activeTop = (activeTop===label)? null: label; renderGrouped(list, activeTop); };
              topWrap.appendChild(b);
            }
            // Only show pills if more than one top-level segment
            if(firstSegments.length>1){ firstSegments.forEach(seg=> pill(seg)); inner.appendChild(topWrap); }
            let working = list.slice();
            if(activeTop){ working = working.filter(p=> (p.split('/')[0]||'')===activeTop); }
            const filterTxt = search.value.toLowerCase().trim();
            if(filterTxt){ working = working.filter(p=> baseEpisodeName(p).toLowerCase().includes(filterTxt)); }
            if(!working.length){ const empty=document.createElement('div'); empty.textContent='(no media files)'; empty.className='empty-label'; inner.appendChild(empty); return; }
            // Group by second segment (show)
            const byShow = new Map();
            for(const rel of working){
              const segs = rel.split('/');
              const show = segs[1] || '(misc)';
              if(!byShow.has(show)) byShow.set(show, []);
              byShow.get(show).push(rel);
            }
            const showKeys = Array.from(byShow.keys()).sort();
            for(const show of showKeys){
              const header = document.createElement('div'); header.className='picker-section-header'; header.textContent=show; inner.appendChild(header);
              const eps = byShow.get(show);
              eps.sort((a,b)=> a.localeCompare(b, undefined, {numeric:true}));
              for(const rel of eps){
                const row = document.createElement('div'); row.className='picker-row'; row.tabIndex=0;
                const epName = baseEpisodeName(rel);
                row.innerHTML = '<span class="flex-grow truncate">' + epName.replace(/</g,'&lt;') + '</span><span class="muted fs-11">' + shortName(rel) + '</span>';
                highlightCurrent(row, rel);
                // Hover styling now via CSS .picker-row:hover; remove JS handlers
                row.onclick = () => { if (lastState && lastState.path === rel) { wrap.remove(); return; } send('load', { path: rel }); wrap.remove(); showToast('Loading ' + epName); };
                row.onkeydown = e => { if(e.key==='Enter'){ row.click(); } };
                inner.appendChild(row);
              }
            }
          }
          fetch('/api/files').then(r => r.json()).then(list => { if(!Array.isArray(list)) list=[]; const files=list; renderGrouped(files, null); search.oninput = () => { renderGrouped(files, null); }; search.focus(); }).catch(() => { status.textContent='Failed to load file list.'; });
          box.appendChild(search); box.appendChild(inner); wrap.appendChild(box); document.body.appendChild(wrap);
          box.querySelector('#mpClose').onclick = () => wrap.remove();
          const homeBtn = box.querySelector('#mpHome');
          if (homeBtn) { homeBtn.onclick = () => {
            try { forceHomeCleanup(); } catch {}
            send('unload', {});
            wrap.remove();
            showToast('Returning to home');
          }; }
          wrap.addEventListener('click', e => { if (e.target === wrap) wrap.remove(); });
          document.addEventListener('keydown', function escHandler(ev) { if (ev.key === 'Escape') { try { wrap.remove(); } catch { } document.removeEventListener('keydown', escHandler); } });
        }
        mediaBtn.onclick = openMediaPicker;
        // Expose picker globally for home screen button
        window.openMediaPicker = openMediaPicker;
        ctr.appendChild(mediaBtn);
      }
      // Expose helper to auto-enable default subtitles (English preferred)
      window.enableDefaultSubs = async function(spec=(WP_CLIENT_CONFIG?.subtitles?.preferredLang||'eng')){
        if (subsEnabled){ autoSubsAttempted=true; return true; }
        try {
          const ok = await ensureSubTrack(spec);
          if(!ok) return false;
          subsEnabled = true; updateSubBtn(); await buildCcSelect(); if(currentLang) ccSelect.value=currentLang; renderActiveCues();
          autoSubsAttempted=true; return true;
        } catch { return false; }
      };
  let autoSubsScheduled = false;
  function scheduleAutoSubs(retries=(WP_CLIENT_CONFIG?.subtitles?.autoEnableRetriesInitial||5)){
        if(subsEnabled || autoSubsAttempted || autoSubsScheduled) return;
        autoSubsScheduled = true; // guard race with metadata + initial call
        setTimeout(async ()=>{
          if(subsEnabled){ autoSubsAttempted=true; autoSubsScheduled=false; return; }
          const ok = await window.enableDefaultSubs('eng');
          if(!ok && retries>0){ autoSubsScheduled=false; scheduleAutoSubs(retries-1); }
          else { autoSubsScheduled=false; }
  }, (WP_CLIENT_CONFIG?.subtitles?.autoEnableDelayMs)||300);
      }
  // Expose for outside callers (e.g., metadata listener)
  window.scheduleAutoSubs = scheduleAutoSubs;
  const fsBtn = mkBtn('⛶', 'Fullscreen');
  fsBtn.setAttribute('data-darkreader-ignore','');
      // Enlarge fullscreen button to match pill group height
  fsBtn.classList.add('btn-large');
      fsBtn.onclick = () => { if (document.fullscreenElement) document.exitFullscreen(); else videoWrap.requestFullscreen().catch(() => { }); };
      // Double click toggles wrapper fullscreen (prevents native video-only fs)
      video.addEventListener('dblclick', e => { e.preventDefault(); if (document.fullscreenElement) document.exitFullscreen(); else videoWrap.requestFullscreen().catch(() => { }); });
  const subBtn = mkBtn('CC', 'Toggle Subtitles');
  subBtn.classList.add('btn-media-opt');
  const ccSelect = document.createElement('select'); ccSelect.className = 'select-chip'; ccSelect.style.display = 'none'; ccSelect.style.maxWidth = '170px';
      // Removed Picture-in-Picture / Pop-out feature
  const volWrap = document.createElement('div'); volWrap.className = 'cluster';
      volWrap.onmouseenter = () => volWrap.style.background = '#333';
      volWrap.onmouseleave = () => volWrap.style.background = '#222';
  const styleSelect = document.createElement('select'); styleSelect.className = 'select-chip'; styleSelect.style.display = 'inline-block'; styleSelect.style.maxWidth = '150px';
      STYLE_IDS.forEach(id => { const o = document.createElement('option'); o.value = id; o.textContent = { default: 'Default', outline: 'Outline', yellow: 'Yellow', box: 'Box' }[id]; styleSelect.appendChild(o); });
  styleSelect.value = currentStyle; styleSelect.onchange = () => { const prev = currentStyle; applyStyle(styleSelect.value); telemetry('subs.style.change',{from: prev, to: styleSelect.value}); };
  const volLabel = document.createElement('span'); volLabel.textContent = 'Vol'; volLabel.className='vol-label';
    const vol = document.createElement('input'); vol.type = 'range'; vol.min = '0'; vol.max = '1'; vol.step = '0.01';
  vol.value = (video.volume && video.volume > 0) ? video.volume : 1;
  // Restore unmute-on-volume-change logic so viewer can enable sound after autoplay.
  function updateVolFill(){ const v = Number(vol.value); const pct = v*100; vol.style.setProperty('--pct', pct+'%'); }
  let __lastVolTelemTs = 0; let __lastVolValue = video.volume;
  vol.oninput = () => {
    const newVal = Number(vol.value);
    const before = video.volume;
    // Always set base video volume (so when leaving sidecar it reflects slider)
    video.volume = newVal;
    if(sidecarMode){
      // Keep primary video muted while sidecar active; adjust sidecar volume instead
      if(sidecarAudioEl){ try { sidecarAudioEl.volume = newVal; } catch{} }
      if(!video.muted){ video.muted = true; telemetry && telemetry('audio.sidecar.forceMute',{ reason:'vol-change' }); }
    } else {
      if(video.volume>0 && video.muted){ video.muted = false; }
    }
    const now=Date.now(); const dv=Math.abs(video.volume-__lastVolValue);
    if(dv>0.02 || (now-__lastVolTelemTs)>80){ telemetry('media.volume.change',{from: before, to: video.volume, muted: video.muted, sidecar: sidecarMode }); __lastVolTelemTs=now; __lastVolValue=video.volume; }
    updateVolFill();
  };
  setTimeout(updateVolFill,40);
      volWrap.appendChild(volLabel); volWrap.appendChild(vol);
      // Group CC related controls into a single pill
    const ccWrap = document.createElement('div');
  ccWrap.className = 'cluster cluster-tight';
      ccWrap.onmouseenter = () => ccWrap.style.background = '#333';
      ccWrap.onmouseleave = () => ccWrap.style.background = '#222';
      // Audio track selection button (cycles embedded audio tracks)
  const audioBtn = mkBtn('Audio', 'Cycle audio track');
  audioBtn.setAttribute('data-darkreader-ignore','');
      audioBtn.classList.add('btn-media-opt');
      let audioTracksMeta = []; // [{index,lang,title,default}]
      let currentAudioLogical = null; // index within audioTracksMeta array
  // Simplified sidecar handling will be defined later after track load
  let sidecarMode = false; // active selection is sidecar
  let sidecarAudioEl = null; let sidecarLang = null;
      async function loadAudioTracks(){
        if(!video.src){ audioTracksMeta=[]; currentAudioLogical=null; sidecarMode=false; updateAudioBtn(); return; }
        try {
          const r = await fetch('/media/current-audio.json?_=' + Date.now()); if(!r.ok) return;
          const j = await r.json(); if(!j || !Array.isArray(j.tracks)) return;
          audioTracksMeta = j.tracks.map((t,i)=>({ logical:i, ...t }));
          telemetry && telemetry('audio.tracks.list',{ count: audioTracksMeta.length, kinds: Array.from(new Set(audioTracksMeta.map(t=>t.kind))).slice(0,6) });
          const jp = audioTracksMeta.find(t=> /^(jpn|ja|japanese)$/.test((t.lang||'').toLowerCase()));
          const defFlag = audioTracksMeta.find(t=> t.default);
          const chosen = jp || defFlag || audioTracksMeta[0];
          currentAudioLogical = chosen ? chosen.logical : null;
          applyAudioSelection();
        } catch(e){ telemetry && telemetry('audio.tracks.error',{ msg: e && e.message }); }
        updateAudioBtn();
      }
      function friendlyAudioLabel(t){
        if (!t) return 'Audio';
        const langMap = { eng:'EN', en:'EN', jpn:'JP', ja:'JP', japanese:'JP', english:'EN' };
  let lab = (t.lang && langMap[t.lang]) || (t.lang && t.lang!=='und' ? t.lang.substring(0,2).toUpperCase() : ('A'+(t.logical+1)));
        if (t.title) {
          const shortTitle = t.title.length>10? t.title.slice(0,10)+'…' : t.title;
          lab += ':' + shortTitle;
        }
        return lab;
      }
      function updateAudioBtn(){
        if (!audioTracksMeta.length) { audioBtn.textContent='Audio'; delete audioBtn.dataset.active; audioBtn.style.background='#222'; return; }
        const cur = audioTracksMeta.find(t=>t.logical===currentAudioLogical) || audioTracksMeta[0];
        audioBtn.textContent = friendlyAudioLabel(cur);
  // Build tooltip with all tracks
  audioBtn.title = 'Audio tracks: ' + audioTracksMeta.map(t=> (t.logical===currentAudioLogical?'*':' ') + friendlyAudioLabel(t) + (t.lang? ' ['+t.lang+']':'') ).join(' | ');
        audioBtn.dataset.active='1'; audioBtn.style.background='#2e78d2'; audioBtn.style.color='#fff';
      }
      let __prevUserMute = false;
      function applyAudioSelection(){
        const target = audioTracksMeta.find(t=>t.logical===currentAudioLogical);
        if(!target){ return; }
        const wantSidecar = target.kind==='sidecar';
  sidecarMode = wantSidecar; // set first for enforcement visibility
  // Defer real enable/disable & element management to central enforcer
  enforceAudioMode('selection', target);
      }
      audioBtn.onclick = () => {
        if (!audioTracksMeta.length) { loadAudioTracks(); return; }
        if (currentAudioLogical==null) currentAudioLogical=0; else currentAudioLogical = (currentAudioLogical+1) % audioTracksMeta.length;
        applyAudioSelection(); updateAudioBtn();
        const curMeta = audioTracksMeta.find(t=>t.logical===currentAudioLogical);
        telemetry('audio.track.cycle',{ label: friendlyAudioLabel(curMeta), sidecar: !!(curMeta && curMeta.kind==='sidecar'), lang: curMeta && curMeta.lang });
        showToast('Audio: ' + friendlyAudioLabel(curMeta));
        // Attempt gentle unmute / resume so user doesn't need a manual seek to hear new track
        setTimeout(()=>{
          try {
            const cur = curMeta;
            if(!sidecarMode){
              if((typeof userMuted==='undefined' || !userMuted) && video.muted){ video.muted=false; telemetry && telemetry('audio.track.autounmute',{ track: cur && cur.lang || null }); }
            } else if(sidecarAudioEl && !video.paused){ const p = sidecarAudioEl.play(); if(p && p.catch) p.catch(()=>{}); }
            if(lastState && !lastState.paused && video.paused){ const p2=video.play(); if(p2 && p2.catch) p2.catch(()=>{}); }
          } catch{}
        }, 120);
      };
      // Expose a global helper to forcibly stop & remove sidecar audio (used on unload transitions for viewers)
      window.stopSidecarAudio = function(){
        try {
          if(sidecarAudioEl){ sidecarAudioEl.pause(); sidecarAudioEl.remove(); }
        } catch{}
        sidecarAudioEl=null; sidecarLang=null; sidecarMode = false;
      };
      // Maintain sidecar play/pause sync
  video.addEventListener('play', ()=>{ telemetry('media.play.local'); if(sidecarMode && sidecarAudioEl){ try { const p=sidecarAudioEl.play(); if(p&&p.catch)p.catch(()=>{}); } catch{} } });
  video.addEventListener('pause', ()=>{ telemetry('media.pause.local'); if(sidecarMode && sidecarAudioEl){ try { sidecarAudioEl.pause(); } catch{} } });
  video.addEventListener('seeking', ()=>{ if(sidecarMode && sidecarAudioEl){ try { sidecarAudioEl.currentTime = video.currentTime; } catch{} } });
      // Re-probe audio tracks when metadata loads or media changes
  video.addEventListener('loadedmetadata', () => { telemetry('media.audio.trackscan.start'); setTimeout(()=>{ loadAudioTracks(); telemetry('media.audio.trackscan.done'); enforceAudioMode('metadata-post-scan'); }, 100); });
  const __origApplyState = applyState; // intercept to detect media change
  applyState = function(s){
    const oldPath = lastState && lastState.path;
    __origApplyState(s);
    if (!s || s.path !== oldPath) { audioTracksMeta=[]; currentAudioLogical=null; updateAudioBtn(); if (s && s.path) setTimeout(loadAudioTracks, 250); }
  };

  // Central exclusive audio mode enforcement
  function enforceAudioMode(reason, targetOverride){
    try {
      const target = targetOverride || audioTracksMeta.find(t=>t.logical===currentAudioLogical) || null;
      let disabled=0, enabled=0;
      if(sidecarMode){
        // Create sidecar if missing
        if(!sidecarAudioEl){
          sidecarAudioEl = document.createElement('audio'); sidecarAudioEl.preload='auto'; sidecarAudioEl.crossOrigin='anonymous'; sidecarAudioEl.style.display='none'; document.body.appendChild(sidecarAudioEl); sidecarAudioEl.volume = video.volume; video.addEventListener('volumechange', ()=>{ try { if(sidecarAudioEl) sidecarAudioEl.volume = video.volume; } catch{} }); telemetry && telemetry('audio.sidecar.create',{}); }
        // Load src if mismatch
        if(target && target.kind==='sidecar'){
          if(!sidecarLang || sidecarLang!==target.lang){
            try { sidecarAudioEl.pause(); } catch{}
            sidecarAudioEl.src = target.url; sidecarLang = target.lang; try { sidecarAudioEl.load(); } catch{}
            setTimeout(()=>{ try { sidecarAudioEl.currentTime = video.currentTime; } catch{} }, 80);
            if(telemetry){ if(!window.__lastSidecarActiveKey) window.__lastSidecarActiveKey=null; const key=(typeof lastRev==='number'?lastRev:'_')+':'+sidecarLang; if(window.__lastSidecarActiveKey!==key){ window.__lastSidecarActiveKey=key; telemetry('audio.sidecar.active',{ lang: sidecarLang }); } }
          }
        }
        // Disable all embedded tracks
        try { const list=video.audioTracks; if(list && list.length){ for(let i=0;i<list.length;i++){ if(list[i].enabled){ list[i].enabled=false; disabled++; } } } } catch{}
        if(!video.__sidecarActive){ __prevUserMute = video.muted; video.__sidecarActive=true; }
        if(!video.muted) video.muted=true;
        if(sidecarAudioEl && !video.paused){
          // Defer start for very early hot join until main video truly enters playing state
          if(initialSync){
            const starter = ()=>{ try { const p=sidecarAudioEl.play(); if(p&&p.catch) p.catch(()=>{}); } catch{} };
            video.addEventListener('playing', function __once(){ video.removeEventListener('playing', __once); starter(); }, { once:true });
          } else {
            try { const p=sidecarAudioEl.play(); if(p&&p.catch) p.catch(()=>{}); } catch{}
          }
        }
      } else {
        // Embedded mode: enable only chosen track language (if any meta known)
        try {
          const list=video.audioTracks; if(list && list.length){
            let targetLang = target && target.lang ? (target.lang||'').toLowerCase() : null;
            for(let i=0;i<list.length;i++){
              const lang=(list[i].language||'').toLowerCase();
              const should = (!targetLang) ? (i===0) : (lang===targetLang);
              if(list[i].enabled!==should){ list[i].enabled=should; if(should) enabled++; else disabled++; }
            }
          }
        } catch{}
  if(video.__sidecarActive){ video.__sidecarActive=false; video.muted = (__prevUserMute || userMuted); } else if(!userMuted) video.muted=false;
  // Remove lingering sidecar element when switching back to embedded to avoid mute confusion
  if(sidecarAudioEl){ try { sidecarAudioEl.pause(); sidecarAudioEl.remove(); } catch{} sidecarAudioEl=null; sidecarLang=null; telemetry && telemetry('audio.sidecar.remove',{ reason:'mode-exit' }); }
      }
      telemetry && telemetry('audio.mode.enforce',{ reason, sidecar: sidecarMode, enabled, disabled, targetLang: target && target.lang || null });
    } catch(e){ telemetry && telemetry('audio.mode.enforce.error',{ reason, msg: e && e.message }); }
  }

  // Hook additional events to keep consistency
  video.addEventListener('seeked', ()=>{ enforceAudioMode('seeked'); });
  ccWrap.appendChild(audioBtn);
  ccWrap.appendChild(subBtn); ccWrap.appendChild(ccSelect); ccWrap.appendChild(styleSelect);
  // Append CC group and volume now; fullscreen will be appended at the very end to guarantee rightmost position
  ctr.appendChild(ccWrap); ctr.appendChild(volWrap);
  // (Removed previous volume reposition hack; we will explicitly place volume at far left after assembling remaining buttons.)
      // Chat toggle button (moved from separate expand/collapse UI)
  const chatToggleBtn = mkBtn('Chat', 'Toggle Chat Panel');
  chatToggleBtn.setAttribute('data-darkreader-ignore','');
  // Match sizing of Play/Media/Fullscreen buttons
  chatToggleBtn.classList.add('btn-large');
      // Robust home cleanup helper
  function forceHomeCleanup(){ telemetry('home.forceCleanup');
        const afterExit = ()=>{
          try { if(sidecarAudioEl){ sidecarAudioEl.pause(); sidecarAudioEl.remove(); sidecarAudioEl=null; sidecarLang=null; } } catch{}
          try { video.pause(); video.removeAttribute('src'); video.load(); } catch{}
          refreshSubs();
          noMediaGlobal = true;
          if (typeof startStarfield==='function') startStarfield();
          if (video) video.style.display='none';
          if (homeSelectEl) { homeSelectEl.classList.remove('hidden'); homeSelectEl.classList.add('inline-flex'); }
        };
        // If video currently visible trigger exit wipe with starfield starting behind
        if(video && video.style.display!== 'none') {
          if (typeof startStarfield==='function') startStarfield();
          triggerWipeExit(afterExit);
        } else { afterExit(); }
      }
      // Fallback safety: if unload state not reflected after 2s, force local cleanup
  function scheduleHomeFallback(){ setTimeout(()=>{ if(!lastState || lastState.path){ telemetry('home.fallback.trigger'); forceHomeCleanup(); } }, 2000); }
      function updateChatToggle() {
        const open = !chatPanel.classList.contains('collapsed');
        chatToggleBtn.textContent = 'Chat';
        if (open) { chatToggleBtn.dataset.active = '1'; chatToggleBtn.style.background = '#2e78d2'; chatToggleBtn.style.color = '#fff'; }
        else { delete chatToggleBtn.dataset.active; chatToggleBtn.style.background = '#222'; chatToggleBtn.style.color = '#eee'; }
      }
      window.updateChatToggle = updateChatToggle;
      // Apply persisted collapsed state before initial styling
  if (localStorage.chatCollapsed === '1') { chatPanel.classList.add('collapsed'); } else { chatPanel.classList.remove('collapsed'); }
  chatToggleBtn.onclick = () => { const opening = chatPanel.classList.contains('collapsed'); if (opening) { expandChat(); } else { collapseChat(); } updateChatToggle(); updateFloatingVisibility(); telemetry('chat.toggle', {open: opening}); };
      // (chat button appended after overlay to get order: overlay then chat)
      // Floating chat overlay toggle (converted to button)
      const overlayBtn = mkBtn('Overlay', 'Show chat overlay when chat is collapsed or fullscreen');
  // Match large pill sizing
  overlayBtn.classList.add('btn-large');
      function overlayActive() { return localStorage.floatChatEnabled !== '0'; }
      function updateOverlayBtn() {
        const active = overlayActive();
        overlayBtn.classList.remove('btn-active','btn-inactive');
        if (active) { overlayBtn.dataset.active = '1'; overlayBtn.classList.add('btn-active'); }
        else { delete overlayBtn.dataset.active; overlayBtn.classList.add('btn-inactive'); }
      }
  overlayBtn.onclick = () => { const now = !(overlayActive()); localStorage.floatChatEnabled = now ? '1' : '0'; updateOverlayBtn(); updateFloatingVisibility(); telemetry('overlay.toggle', {on: now}); };
      updateOverlayBtn();
      ctr.appendChild(overlayBtn);
  // Dev status overlay (admin only)
  let devPanel=null; let devVisible=false; let devTimer=null; let currentDevTab='connections';
  function formatMs(ms){ const s=Math.floor(ms/1000); const m=Math.floor(s/60); const h=Math.floor(m/60); const ss=(s%60).toString().padStart(2,'0'); const mm=(m%60).toString().padStart(2,'0'); if(h) return h+':'+mm+':'+ss; return mm+':'+ss; }
  function ensureDevPanel(){ if(devPanel) return; devPanel=document.createElement('div'); devPanel.id='devPanel'; devPanel.className='dev-panel'; devPanel.innerHTML='<div class="dev-header"><div class="dev-tabs"><button id="devTabConn" class="dev-tab active">Connections</button><button id="devTabBuff" class="dev-tab">Buffer</button><span id="devBuffAll10" class="dev-buff-all10"></span></div><span id="devRefresh" class="dev-refresh" title="Refresh">⟳</span></div><div id="devBody" class="dev-rows"></div><div id="devBodyBuffer" class="dev-rows" style="display:none"></div>'; videoWrap.appendChild(devPanel); const refresh=()=>{ if(currentDevTab==='connections') fetchConnections(); else fetchDelivery(); }; devPanel.querySelector('#devRefresh').onclick=refresh; const tabConn=devPanel.querySelector('#devTabConn'); const tabBuff=devPanel.querySelector('#devTabBuff'); tabConn.onclick=()=>{ currentDevTab='connections'; tabConn.classList.add('active'); tabBuff.classList.remove('active'); devPanel.querySelector('#devBody').style.display=''; devPanel.querySelector('#devBodyBuffer').style.display='none'; fetchConnections(); }; tabBuff.onclick=()=>{ currentDevTab='buffer'; tabBuff.classList.add('active'); tabConn.classList.remove('active'); devPanel.querySelector('#devBody').style.display='none'; devPanel.querySelector('#devBodyBuffer').style.display=''; fetchDelivery(); }; }
  // Telemetry helpers
  function telemetry(ev, data){ try { if(ws && ws.readyState===1){ ws.send(JSON.stringify({type:'telemetry', ev, data, ts:Date.now()})); } } catch(e){} }
  function clientLog(cat,msg,fields){ try { if(ws && ws.readyState===1){ ws.send(JSON.stringify({type:'client-log', cat, msg, fields})); } } catch(e){} }
  // expose globally early
  try { window.clientLog = clientLog; } catch{}
  // Expose globally for later scripts outside this closure referencing telemetry()
  try { window.telemetry = telemetry; } catch {}
  function telemetricClick(el, evName, extra){ if(!el) return; el.addEventListener('click', (e)=> telemetry(evName, typeof extra==='function'? extra(e): extra)); }
  async function fetchConnections(){ if(!devVisible || currentDevTab!=='connections') return; try { const r=await fetch('/api/debug/clients?_=' + Date.now()); if(!r.ok) return; const j=await r.json(); const body=devPanel.querySelector('#devBody'); if(!body) return; body.innerHTML=''; const serverNow = j.serverNow||Date.now(); const mediaNow = j.mediaNow; const mediaPaused = j.mediaPaused; const mediaTotalBytes = j.mediaTotalBytes||0; const header=document.createElement('div'); header.className='dev-row header'; header.innerHTML='<span class="id-col">ID</span><span class="name-col">User</span><span class="dur-col">Up</span><span class="drift-col">Drift</span><span class="rate-col" title="Avg / Recent down (kB/s)">Down</span><span class="in-col" title="Inbound ws (kB)">In</span><span class="out-col" title="Outbound ws / media / combined (kB)">Out</span><span class="pct-col" title="% file fetched">%</span>'; body.appendChild(header); (j.clients||[]).forEach(c=>{ let driftStr='--'; if(c.drift!=null){ const ageMs = c.driftAgeMs!=null? c.driftAgeMs : (serverNow - (c.lastPos && c.lastPos.ts || serverNow)); const stale = ageMs > 2000; driftStr = (c.drift>0?'+':'') + c.drift.toFixed(2)+'s' + (stale?'~':''); } else if(c.lastPos && mediaNow!=null){ const ageSec=(serverNow-(c.lastPos.ts||serverNow))/1000; const expectedAtSample = mediaPaused? mediaNow : (mediaNow - ageSec); const d=c.lastPos.t-expectedAtSample; driftStr=(d>0?'+':'')+d.toFixed(2)+'s'; } const downKBs = c.downBps!=null? (c.downBps/1024).toFixed(1)+'kB/s':'--'; const rDownKBs = c.rDownBps!=null? (c.rDownBps/1024).toFixed(1)+'kB/s':'--'; const totalInKB = c.bytesIn!=null? (c.bytesIn/1024).toFixed(0):'--'; const wsOutKB = c.bytesOut!=null? (c.bytesOut/1024).toFixed(0):'--'; const mediaKB = c.mediaBytes!=null? (c.mediaBytes/1024).toFixed(0):'--'; const combinedKB = ((c.bytesOut||0)+(c.mediaBytes||0))/1024; const combinedStr = isFinite(combinedKB)? combinedKB.toFixed(0):'--'; const pct = (mediaTotalBytes && c.mediaBytes!=null)? Math.min(100,(c.mediaBytes/mediaTotalBytes)*100).toFixed(1):'--'; const row=document.createElement('div'); row.className='dev-row'; const driftWarn=(driftStr!=='--' && /[-+]?\d/.test(driftStr) && Math.abs(parseFloat(driftStr))>5); row.innerHTML=`<span class="id-col">${c.id}</span><span class="name-col" style="color:${CHAR_COLOR_HEX[c.color]||'#ccc'}" title="${c.color||''}">${c.name||c.color||'anon'}</span><span class="dur-col">${formatMs(c.connectedMs||0)}</span><span class="drift-col ${driftWarn?'drift-warn':''}" title="age ${(c.driftAgeMs||0)}ms">${driftStr}</span><span class="rate-col" title="avg / recent">${downKBs}\n${rDownKBs}</span><span class="in-col">${totalInKB}</span><span class="out-col">${wsOutKB} / ${mediaKB} / ${combinedStr}</span><span class="pct-col">${pct}</span>`; body.appendChild(row); }); } catch(e){ console.warn('dev fetch fail',e); } }
  async function fetchDelivery(){ if(!devVisible || currentDevTab!=='buffer') return; try { const r=await fetch('/api/debug/delivery?_=' + Date.now()); if(!r.ok) return; const j=await r.json(); const body=devPanel.querySelector('#devBodyBuffer'); if(!body) return; body.innerHTML=''; const header=document.createElement('div'); header.className='dev-row header'; header.innerHTML='<span class="id-col">ID</span><span class="name-col">GUID</span><span class="dur-col" title="Color">Clr</span><span class="pct-col" title="Bytes fetched">Bytes</span><span class="pct-col" title="Percent">%</span><span class="dur-col" title="Ranges fetched">Rg</span><span class="rate-col" title="Last range bytes">Last</span>'; body.appendChild(header); let all10=true; (j.perClient||[]).forEach(c=>{ const pct = (c.percent!=null)? (Math.min(100,c.percent*100).toFixed(1)+'%'):'--'; if(!(c.percent!=null && c.percent>=0.10)) all10=false; const row=document.createElement('div'); row.className='dev-row'; row.innerHTML=`<span class="id-col">${c.id}</span><span class="name-col" style="font-size:10px;opacity:.8">${c.guid?c.guid.slice(0,8):''}</span><span class="dur-col" style="color:${CHAR_COLOR_HEX[c.color]||'#ccc'}">${c.color||''}</span><span class="pct-col">${c.mediaBytes!=null? (c.mediaBytes/1024).toFixed(0)+'k':''}</span><span class="pct-col">${pct}</span><span class="dur-col">${c.rangeCount||0}</span><span class="rate-col">${c.lastRange? (c.lastRange.bytes|| ( (c.lastRange.end - c.lastRange.start +1) )): ''}</span>`; body.appendChild(row); }); const allEl=devPanel.querySelector('#devBuffAll10'); if(allEl) { allEl.textContent = (j.perClient && j.perClient.length && all10)? 'All >=10% ✓' : ''; allEl.style.color = all10? '#3a3':'#888'; } } catch(e){ console.warn('delivery fetch fail', e); }
  }
  function toggleDev(){
    if(!isAdmin) return;
    ensureDevPanel();
    devVisible = !devVisible;
    devPanel.style.display = devVisible ? 'block' : 'none';
    if(devVisible){
  if(currentDevTab==='connections') fetchConnections(); else fetchDelivery();
      if(devTimer) clearInterval(devTimer);
  devTimer=setInterval(()=>{ if(currentDevTab==='connections') fetchConnections(); else fetchDelivery(); },1000); // tighten to 1s when panel visible
    } else {
      if(devTimer){ clearInterval(devTimer); devTimer=null; }
    }
    updateDevBtn();
  }
  const devBtn = mkBtn('Dev','Show connection status');
  // Match large pill sizing
  devBtn.classList.add('btn-large');
  function updateDevBtn(){
    devBtn.classList.remove('btn-active','btn-inactive');
    if(devVisible){ devBtn.dataset.active='1'; devBtn.classList.add('btn-active'); }
    else { delete devBtn.dataset.active; devBtn.classList.add('btn-inactive'); }
  }
  if(isAdmin){ devBtn.onclick=(e)=>{ telemetry('dev.toggle', {on: !devVisible}); toggleDev(); }; ctr.appendChild(devBtn); updateDevBtn(); }
  ctr.appendChild(chatToggleBtn);
  updateChatToggle();
      // Final ordering adjustments:
      // Admin: Play (leftmost), then Volume; Viewer: Volume leftmost. Fullscreen always rightmost.
      if (isAdmin && playBtn && playBtn.parentNode === ctr) {
        ctr.insertBefore(playBtn, ctr.firstChild);
      }
      if (volWrap.parentNode === ctr) {
        if (isAdmin && playBtn && playBtn.parentNode === ctr) {
          ctr.insertBefore(volWrap, playBtn.nextSibling);
        } else {
          ctr.insertBefore(volWrap, ctr.firstChild);
        }
      }
      ctr.appendChild(fsBtn);
      function updateSubBtn() {
        subBtn.textContent = 'CC';
        if (subsEnabled && subTrackEl && subTrackEl.track) { subBtn.dataset.active = '1'; subBtn.style.background = '#2e78d2'; subBtn.style.color = '#fff'; }
        else { delete subBtn.dataset.active; subBtn.style.background = '#222'; subBtn.style.color = '#eee'; }
      }
      async function buildCcSelect() {
        if (!availableSubs.length) { availableSubs = await fetchSubsList(); }
        ccSelect.innerHTML = '';
        if (!availableSubs.length) { ccSelect.style.display = 'none'; return; }
        availableSubs.forEach(t => {
          const o = document.createElement('option'); o.value = t.lang;
          let label = t.label || t.lang;
          const normLang = (t.lang || '').toLowerCase();
          const normLabel = (label || '').toLowerCase();
          // If label missing/looks like raw code or very short, map to friendly name
          if (!t.label || normLabel === normLang || label.length <= 3) {
            // Support compound identifiers like spa.spanish-latin-america
            if (LANG_DISPLAY[normLang]) label = LANG_DISPLAY[normLang];
            else if (LANG_DISPLAY[t.lang]) label = LANG_DISPLAY[t.lang];
          }
          // Additional normalization for Spanish variants where slug added original code (e.g. "spanish-latin-america spa")
          if (/^spanish-latin-america\b/i.test(normLabel)) label = 'Spanish (Latin America)';
          else if (/^spanish\b/i.test(normLabel)) label = 'Spanish';
          o.textContent = label;
          ccSelect.appendChild(o);
        });
  ccSelect.style.display = 'inline-block';
  if (subsEnabled && currentLang) ccSelect.value = currentLang;
      }
  subBtn.onclick = async () => { if (!subsEnabled) { const ok = await ensureSubTrack(currentLang||'eng'); if (!ok) { showToast('No subtitles'); telemetry('subs.enable.fail'); return; } subsEnabled = true; updateSubBtn(); await buildCcSelect(); if(currentLang) ccSelect.value = currentLang; renderActiveCues(); telemetry('subs.enable', {lang: currentLang||'eng'}); } else { subsEnabled = false; updateSubBtn(); clearOverlay(); if (subTrackEl && subTrackEl.track) subTrackEl.track.mode = 'hidden'; telemetry('subs.disable'); } };
  ccSelect.onchange = async () => { const v = ccSelect.value; if (!v) return; const prev = currentLang; const ok = await ensureSubTrack(v); if (ok) { subsEnabled = true; updateSubBtn(); renderActiveCues(); telemetry('subs.lang.change',{from: prev, to: v}); } };
      updateSubBtn();
      // Hook into media change by observing src changes
      const mo = new MutationObserver(muts => { for (const m of muts) { if (m.attributeName === 'src') { refreshSubs(); } } });
      mo.observe(video, { attributes: true });
      // Attach controls inside videoWrap so centering & hover logic isolate to video area
      videoWrap.appendChild(ctr);
      // Floating chat container (messages stack upward; newest at bottom)
      const floatChat = document.createElement('div');
      floatChat.id = 'floatChat';
      // Floating chat styling adjusted: more right offset, left alignment
  floatChat.className = 'float-chat';
      videoWrap.appendChild(floatChat);
      function shouldShowFloating() { const enabled = (localStorage.floatChatEnabled !== '0'); const minimized = chatPanel.classList.contains('collapsed'); const fs = isFullscreen(); return enabled && (minimized || fs); }
      function updateFloatingVisibility() { floatChat.style.display = shouldShowFloating() ? 'flex' : 'none'; }
      window.updateFloatingVisibility = updateFloatingVisibility;
      // overlayBtn handles toggling now
  document.addEventListener('fullscreenchange', () => { updateFloatingVisibility(); try { if (document.fullscreenElement) { chatToggleBtn.style.display='none'; } else { chatToggleBtn.style.display='inline-flex'; } if (typeof recenter==='function') recenter(); } catch{} });
  setInterval(() => { if (subsEnabled) renderActiveCues(); }, (WP_CLIENT_CONFIG?.subtitles?.layoutRefreshIntervalMs)||600);
      window.addEventListener('resize', () => { if (subsEnabled) layoutSubs(); resizeSeek(); });
      function resizeSeek(){
        if(!seekWrap || !seek) return;
        // Available width inside control bar minus other groups
        try {
          const barW = ctr.clientWidth || window.innerWidth;
          // Rough width occupied by other control groups
          const other = Array.from(ctr.children).filter(ch=> ch!==seekWrap).reduce((a,c)=> a + c.getBoundingClientRect().width + 12, 0);
          const avail = Math.max(120, barW - other - 60);
          const min = 180, max = 560;
          const target = Math.max(min, Math.min(max, avail));
          seek.style.width = target + 'px';
        } catch {}
      }
  setTimeout(resizeSeek, (WP_CLIENT_CONFIG?.controls?.seekInitialResizeDelayMs)||400);
  setInterval(resizeSeek, (WP_CLIENT_CONFIG?.controls?.seekResizeIntervalMs)||1500); // periodic sanity adjustment
  video.addEventListener('loadedmetadata', ()=>{ layoutSubs(); telemetry('subs.layout'); });

      // Hover / inactivity fade logic
      let hideTimer = null; const HIDE_AFTER = (WP_CLIENT_CONFIG?.chat?.hideAfterMs)||10000; // idle before auto-hide
      function recenter() {
        // Center contents by distributing unused space with pseudo flex spacer
        // Already using justify-content:center, so nothing extra for viewer.
        // For admin, seek may expand; still centered by flex.
      }
      function showCtr() {
        if (noMediaGlobal) return; // suppress controls when no media loaded
  ctr.style.opacity = '1'; ctr.style.pointerEvents = 'auto'; recenter();
  if (mediaTitle.textContent) mediaTitle.style.opacity = '1';
        if (hideTimer) clearTimeout(hideTimer);
        hideTimer = setTimeout(() => { if (!ctr.matches(':hover')) hideCtr(); }, HIDE_AFTER);
      }
      function hideCtr() { ctr.style.opacity = '0'; ctr.style.pointerEvents = 'none'; mediaTitle.style.opacity = '0'; }
      // Expose for applyState to call outside closure
      window.showCtr = showCtr; window.hideCtr = hideCtr;
      // Only show when interacting with video area (not chat)
      // Only trigger showCtr when pointer moves inside the video region itself, not when over chat or floating UI.
      function videoAreaEvent(e){
        if(noMediaGlobal) return;
        const rect = videoWrap.getBoundingClientRect();
        const x = (e.touches? e.touches[0].clientX : e.clientX);
        const y = (e.touches? e.touches[0].clientY : e.clientY);
        if(x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return; // outside
        // Exclude chat panel region (if overlapping in responsive layouts)
        if(chatPanel && chatPanel.contains(e.target)) return;
        showCtr();
      }
      ['mousemove','touchstart'].forEach(ev => videoWrap.addEventListener(ev, videoAreaEvent, { passive:true }));
      videoWrap.addEventListener('mouseleave', () => { if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; } hideCtr(); });
      ctr.addEventListener('mouseenter', () => { if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; } });
      ctr.addEventListener('mouseleave', () => {
        // Pointer left controls but may still be inside video area; start (or restart) full idle timer
        if (hideTimer) { clearTimeout(hideTimer); }
        hideTimer = setTimeout(() => { if (!ctr.matches(':hover')) hideCtr(); }, HIDE_AFTER);
      });
      videoWrap.addEventListener('mouseleave', () => { hideCtr(); });
      window.addEventListener('resize', recenter);
      // (Admin keeps native controls)
      // Auto-enable subtitles on first load
  // Removed early auto-enable; handled via scheduleAutoSubs on media load
      // Initial reveal
  setTimeout(showCtr, (WP_CLIENT_CONFIG?.controls?.initialShowDelayMs)||100);
      video.addEventListener('contextmenu', e => e.preventDefault());
      // Optionally prevent manual seeking via keyboard/mouse (native controls removed anyway)
      video.addEventListener('seeking', () => { if (!isAdmin && lastState && Math.abs(video.currentTime - lastState.t) > 1) { suppress = true; video.currentTime = lastState.t; setTimeout(() => suppress = false, 40); } });
    })();
    let ws = null;
    function createSocket(){
      const base = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + (isAdmin ? (location.pathname.startsWith('/watchparty-admin')? '/watchparty-admin' : '/admin') : (location.pathname.startsWith('/watchparty')? '/watchparty' : '/'));
      const url = base + `?key=${encodeURIComponent(ADMIN_KEY||'')}`;
      ws = new WebSocket(url);
  ws.onopen = () => { log('ws open'); pingLoop(); };
      ws.onclose = (ev) => { log('ws close', ev.code, ev.reason); if(isAdmin && ev.code===4003){
        // Replace body with notice (fallback if HTTP race allowed page to load before admin connected)
        document.body.innerHTML = '<div style="font:600 20px system-ui;margin:40px auto;max-width:600px;color:#e6e6e6;padding:32px 38px;background:#121a21;border:1px solid #1d2a33;border-radius:18px;line-height:1.55"><h1 style="margin:0 0 14px;font:600 22px system-ui;letter-spacing:.4px">Admin Session Active</h1><p style="margin:0 0 14px;font:14px/1.55 system-ui">Another admin is already connected. Only one admin session is allowed. If you believe this is stale, wait and retry.</p><button style="all:unset;background:#2e78d2;color:#fff;padding:10px 16px;border-radius:10px;cursor:pointer;font:600 13px system-ui;letter-spacing:.3px" onclick="location.reload()">Retry</button></div>';
      } };
      ws.onmessage = wsMessage;
    }
    let suppress = false;
    let lastState = null;
    let initialSync = true;
    let pendingTarget = null;
    let joinStart = Date.now();
    let latencyMs = 0; // one-way estimate
    let lastPingSent = 0;
    let playAttemptTs = 0;
    let playInFlight = false;
    function log(...a) { console.log('[sync]', ...a); }
    // UI overlays
    const overlay = document.createElement('div');
  overlay.className = 'status-overlay'; if(!VERBOSE) overlay.style.display='none';
    overlay.textContent = 'sync...';
    document.body.appendChild(overlay);
    let lastRev = null;
  // Viewer autoplay gating flag: viewers present before media load must wait for explicit play
  let awaitExplicitPlay = false;
  // Track whether this viewer observed the home (no media) state before first media selection
  let sawHomeBeforeFirstMedia = false;
  // Seek gate client state
  let pendingSeekGate = null; // { gateId, targetT, sentReady }
  let lastGateCompleteTs = 0; // seek gate completion timestamp
  // Host seek gate parity: auto-resume host when gate lifts
  let pendingHostSeekGate = false;
  // Telemetry (viewer diagnostics)
  const telem = { lastCT: 0, stagnation: 0, playErrors: 0, notAllowed: 0, playSuccess: 0, seekAdjusts: 0, enforcedPauses: 0 };
  function bufferRanges() { const arr = []; try { for (let i=0;i<video.buffered.length;i++){ arr.push([video.buffered.start(i).toFixed(2), video.buffered.end(i).toFixed(2)]); } } catch {} return arr; }
  function sampleTelemetry(){
    if(isAdmin) return;
    const ct=video.currentTime; const d=ct - telem.lastCT;
    if(!video.paused && d < 0.05) telem.stagnation++; else telem.stagnation=0;
    const stalled = (!video.paused && telem.stagnation>=3 && video.readyState>=3);
    if (VERBOSE||window.DEBUG_UI) console.log('[telem]', {ct:ct.toFixed(2), d:d.toFixed(2), paused:video.paused, muted:video.muted, rs:video.readyState, ns:video.networkState, buf:bufferRanges(), playOK:telem.playSuccess, playErr:telem.playErrors, notAllowed:telem.notAllowed, seekAdj:telem.seekAdjusts, enforcedPauses:telem.enforcedPauses, stalled});
    telem.lastCT=ct;
  }
  setInterval(sampleTelemetry, (WP_CLIENT_CONFIG?.telemetry?.sampleIntervalMs)||1000);
  // Robust autoplay helper with retry window (guards rare cases play() silently does nothing)
  let autoPlayRetries = 0;
  let autoPlayTimer = null;
  function clearAutoPlayTimer(){ if(autoPlayTimer){ clearInterval(autoPlayTimer); autoPlayTimer=null; } }
  function ensureViewerPlaying(){
    if(isAdmin) return;
    if(awaitExplicitPlay) return; // gated until host plays
    if(!lastState || lastState.paused) { clearAutoPlayTimer(); return; }
    if(!video.src) return;
    if(!video.paused) { clearAutoPlayTimer(); return; }
    const attempt = ++autoPlayRetries;
    telemetry && telemetry('viewer.autoplay.attempt',{attempt});
    const p = video.play();
    if(p && p.then){ p.then(()=>{ if(!video.paused){ telemetry && telemetry('viewer.autoplay.success',{attempt}); clearAutoPlayTimer(); } }).catch(e=>{ telem.playErrors++; if(e && e.name==='NotAllowedError') telem.notAllowed++; telemetry && telemetry('viewer.autoplay.fail',{attempt, name:e?.name, msg:e?.message}); }); }
    if(!autoPlayTimer){ autoPlayTimer = setInterval(()=>{ if(isAdmin || !lastState || lastState.paused){ clearAutoPlayTimer(); return; } if(!video.src || !video.paused){ clearAutoPlayTimer(); return; } if(autoPlayRetries >= 6){ telemetry && telemetry('viewer.autoplay.giveup',{attempts:autoPlayRetries}); clearAutoPlayTimer(); return; } ensureViewerPlaying(); }, 1400); }
  }
  function applyState(s) {
      if (!s) return; const prev = lastState; lastState = s;
      const now = Date.now();
      let target = s.t;
      if (!s.paused) {
        let delta = (now - s.ts - latencyMs) / 1000; if (delta < 0) delta = 0; target += delta;
      }
  const drift = video.currentTime - target;
      // Detect an admin seek (revision does NOT change on seek). Heuristic: new base t differs from predicted timeline > 1.5s
      let isSeek = false;
      if (prev) {
        let expectedFromPrev = prev.t;
        if (!prev.paused) {
          let d = (s.ts - prev.ts) / 1000; if (d < 0) d = 0; expectedFromPrev += d;
        }
        if (Math.abs(s.t - expectedFromPrev) > 1.5) {
          isSeek = true; window.__lastSeekTs = now;
        }
      }
      const noMedia = !s.path;
      if (noMedia) {
        const wasPlayingMedia = !noMediaGlobal; // transition from media -> home
        if (!noMediaGlobal) noMediaGlobal = true;
        if (typeof hideCtr === 'function') hideCtr();
  if (isAdmin) { ensureHomeSelect(); if (homeSelectEl) { homeSelectEl.classList.remove('hidden'); homeSelectEl.classList.add('inline-flex'); } }
        if (video) {
          if (wasPlayingMedia) {
            // Begin starfield behind video before collapsing so wipe reveals it
            if (typeof startStarfield === 'function') startStarfield();
            // Immediately stop any audio (embedded or sidecar) for viewers to avoid lingering sound
            try { if(!isAdmin){ video.pause(); video.muted = true; } } catch {}
            try { if(typeof window.stopSidecarAudio==='function') window.stopSidecarAudio(); } catch {}
            // Defer src unload until after wipe completes to preserve last frame during animation
            triggerWipeExit(() => {
              try {
                video.pause();
                video.removeAttribute('src');
                video.load();
                video.style.display = 'none';
              } catch { }
            });
          } else {
            // Initial home load, no exit animation needed; safe to clear immediately
            if (typeof startStarfield === 'function') startStarfield();
            try {
              video.pause();
              video.removeAttribute('src');
              video.load();
              video.style.display = 'none';
            } catch { }
          }
        }
      } else {
        const wasHome = noMediaGlobal;
        if (noMediaGlobal) noMediaGlobal = false;
        if (wasHome) stopStarfield(); // only stop when actually leaving home
  if (homeSelectEl) { homeSelectEl.classList.add('hidden'); homeSelectEl.classList.remove('inline-flex'); }
        if (wasHome && typeof showCtr === 'function') showCtr();
        if (video) {
          if (wasHome) { triggerWipeEnter(); }
          video.style.display = 'block';
        }
      }
      if (VERBOSE) {
        overlay.textContent = (isAdmin ? '[HOST] ' : '') + (s.path || '') + '\n' + (s.paused ? 'paused' : 'playing') + ` t=${target.toFixed(2)} drift=${drift.toFixed(3)} lat=${latencyMs}ms`;
      } else {
        // Remove file path spam when not verbose
        overlay.textContent = (isAdmin ? '[HOST] ' : '') + (s.paused ? 'paused' : 'playing') + ` lat=${latencyMs}ms`;
      }
  if (lastRev === null) { try { updateMediaTitle(s.path); } catch { } }
  // Record that viewer saw home screen (used to gate autoplay on first media load)
  if (!isAdmin && lastState == null && !s.path) { sawHomeBeforeFirstMedia = true; }
  // If admin requested unload (home) ensure any stray sidecar audio halted
  try { if (noMedia && typeof sidecarAudioEl !== 'undefined' && sidecarAudioEl){ sidecarAudioEl.pause(); } } catch{}
  if (s.rev != null && s.rev !== lastRev) {
        const prevRev = lastRev;
        lastRev = s.rev; initialSync = true; pendingTarget = null; joinStart = Date.now();
        if(!isAdmin){
          const hotJoin = !sawHomeBeforeFirstMedia; // joined after media already selected
          // Autoplay only if hot join AND media already playing; otherwise wait until admin presses play
          awaitExplicitPlay = !hotJoin || s.paused;
          if (awaitExplicitPlay) { try { video.pause(); } catch{} try { video.removeAttribute('autoplay'); } catch{} }
        }
        try { if (window.resetMediaUi) window.resetMediaUi(); } catch { }
        try { updateMediaTitle(s.path); } catch { }
        if (s.path) {
          // New media selected (or admin reload) – admin should align its local currentTime to server baseline
          if (isAdmin) {
            try {
              let adminTarget = s.t;
              if(!s.paused){ let d=(Date.now()-s.ts - latencyMs)/1000; if(d<0)d=0; adminTarget += d; }
              if(adminTarget<0) adminTarget=0;
              suppress=true; video.currentTime=adminTarget; setTimeout(()=>suppress=false,40);
              telemetry && telemetry('admin.reload.sync',{ rev:s.rev, target:Number(adminTarget.toFixed(2)), paused: !!s.paused });
            } catch { suppress=true; video.currentTime=0; setTimeout(()=>suppress=false,40); }
          }
          // Begin actual media load (previous regression: forgot to call setVideoSrc causing 0:00/0:00)
          try { setVideoSrc(s.rev); } catch(e){ console.warn('setVideoSrc failed', e); }
          // Viewer mid-join optimization: pre-compute target so we seek immediately after metadata
          if (!isAdmin) {
            try {
              // Baseline target derived from authoritative state timestamp (s.ts) and current wall time
              let nowWall = Date.now();
              let joinTarget = s.t;
              if (!s.paused) {
                let delta = (nowWall - s.ts - latencyMs)/1000; if (delta < 0) delta = 0; joinTarget += delta;
              }
              if (joinTarget < 0) joinTarget = 0;
              // Defer applying until metadata (pendingTarget used later)
              pendingTarget = joinTarget;
              telemetry && telemetry('join.sync.initial',{ rev: s.rev, target: Number(joinTarget.toFixed(2)), paused: !!s.paused, lat: latencyMs });
            } catch{}
          }
          // Robust load helper with retry for rare initial failure (observed occasional readyState 0 + error in one tab)
          if(!window.__videoLoadAttempts) window.__videoLoadAttempts = 0;
          function setVideoSrc(rev){
            // Robustly init attempt counter (avoid NaN if clobbered)
            if(typeof window.__videoLoadAttempts!=='number' || !isFinite(window.__videoLoadAttempts)) window.__videoLoadAttempts = 0;
            window.__videoLoadAttempts++;
            let attempt = window.__videoLoadAttempts;
            if(!Number.isFinite(attempt)){ telemetry && telemetry('media.load.badAttempt',{ attemptRaw:String(attempt) }); attempt = 0; window.__videoLoadAttempts = 0; }
            const cacheBust = 'r'+attempt+'='+Date.now();
            const guidParam = (currentSelf && currentSelf.guid) ? ('&guid='+encodeURIComponent(currentSelf.guid)) : '';
            const url = '/media/current.mp4?rev=' + rev + '&' + cacheBust + guidParam;
            if (window.DEBUG_UI) console.log('[media] set src attempt', attempt, url);
            telemetry && telemetry('media.load.attempt',{rev:rev, attempt});
            try { video.src = url; video.load(); } catch(e){ console.warn('video load error (immediate)', e); }
            armLoadWatch(rev, s.path || null);
            scheduleRetry(rev, attempt);
          }
          function scheduleRetry(rev, attempt){
            setTimeout(()=>{
              if(video.readyState>0) return;
              if(window.__videoLoadAttempts!==attempt) return;
              if(attempt>=3){ telemetry && telemetry('media.load.giveup',{rev, attempts:attempt}); clientLog('media','load-giveup',{ rev, attempts: attempt }); return; }
              telemetry && telemetry('media.load.retry.timeout',{rev, attemptNext: attempt+1});
              setVideoSrc(rev);
            }, 1800 + (attempt*400));
          }
          // Wipe enter only if coming from home
          if (noMediaGlobal) triggerWipeEnter();
          // Attempt to auto-enable subtitles with retries
          autoSubsAttempted=false; scheduleAutoSubs((WP_CLIENT_CONFIG?.subtitles?.autoEnableRetriesInitial)||5);
        } else {
          // Unloaded -> home; src removal & animation handled in main noMedia branch above
        }
        return; // wait for metadata before applying more
      }
      // Admin is authoritative: don't force drift corrections or playback state changes.
      if (isAdmin) {
        // Auto-resume after seek gate completes (paused->playing transition following an admin seek)
        if(pendingHostSeekGate && prev && prev.paused && !s.paused){
          pendingHostSeekGate = false;
          try { const p = video.play(); if(p && p.catch) p.catch(()=>{}); } catch{}
          telemetry && telemetry('seek.gate.host.resume',{ rev: s.rev, ct: Number(video.currentTime.toFixed(2)) });
          enforceAudioMode('seek-gate-host-resume');
        }
        return;
      }
      // If gating was active and admin just transitioned to playing for this rev, lift gate
      if (awaitExplicitPlay && prev && prev.rev === s.rev && prev.paused && !s.paused) { awaitExplicitPlay = false; ensureViewerPlaying(); }
      if (!isAdmin && pendingSeekGate && !s.paused) {
        lastGateCompleteTs = Date.now();
        pendingSeekGate = null;
        try { if(!video.hasAttribute('autoplay')) video.setAttribute('autoplay',''); } catch{}
        awaitExplicitPlay = false;
        ensureViewerPlaying();
        telemetry('seek.gate.resume',{});
        enforceAudioMode('seek-gate-viewer-resume');
      }
      // Stage initial seek until metadata ready (avoid AbortError / spam seeks)
      if (!isAdmin && initialSync) {
        if (video.readyState < 1) { pendingTarget = target; return; }
        if (pendingTarget != null) { suppress = true; video.currentTime = pendingTarget; pendingTarget = null; setTimeout(() => suppress = false, 60); }
        // After first successful metadata seek mark sync complete (once we have some data)
        if (video.readyState >= 2) { initialSync = false; }
      }
      // On explicit seek, jump viewer to new target immediately (prevents giant drift + false alerts)
      if(!isAdmin && isSeek) {
        suppress = true; try { video.currentTime = target; } catch{} setTimeout(()=> suppress=false, 60);
      }
      // Drift auto-correction still disabled outside seeks; only enforce pause/play alignment
      if(!isAdmin){
        if(s.paused){
          if(!video.paused){ suppress=true; video.pause(); setTimeout(()=>suppress=false,30); telem.enforcedPauses++; }
        } else {
          if(!awaitExplicitPlay) ensureViewerPlaying();
        }
      }
    }
    // Diagnostic logging to trace possible external pauses
    ['play','playing','pause','waiting','stalled','suspend','ended','error'].forEach(ev => {
      video.addEventListener(ev, () => {
        if(ev==='play' || ev==='playing') telem.playSuccess++;
        if(ev==='error') telem.playErrors++;
        if(!isAdmin){
          if(ev==='waiting') { if(!video.paused){ const now=Date.now(); if(!video.__lastWaitingLog || now-video.__lastWaitingLog>900){ video.__lastWaitingLog=now; telemetry('client-waiting',{ ct:Number(video.currentTime.toFixed(2)), rs:video.readyState, buf: bufferRanges() }); } } }
          if(ev==='playing'){ const now=Date.now(); if(!video.__lastResumeLog || now-video.__lastResumeLog>900){ video.__lastResumeLog=now; telemetry('client-resume',{ ct:Number(video.currentTime.toFixed(2)), rs:video.readyState, buf: bufferRanges() }); } }
        }
  if (window.DEBUG_UI) console.log('[video-event]', ev, 't=', video.currentTime.toFixed(2), 'readyState', video.readyState, 'networkState', video.networkState, 'paused', video.paused, 'muted', video.muted);
      });
    });
    // Lightweight stall detector (viewer only) – considers stagnation of currentTime while expected should advance
    let stallActive=false; let stallStartTs=0; let stallStartCT=0; let stallStartDrift=0;
    function currentDrift(){
      if(!lastState) return 0;
      let target=lastState.t; if(!lastState.paused){ let d=(Date.now()-lastState.ts-latencyMs)/1000; if(d<0)d=0; target += d; }
      return video.currentTime - target;
    }
    setInterval(()=>{
      if(isAdmin || !lastState || lastState.paused) return;
      const driftNow = currentDrift();
      // If video should be playing (readyState>=2) but currentTime not moving much and buffer appears present
      const bufAhead = (function(){ try { for(let i=0;i<video.buffered.length;i++){ const s=video.buffered.start(i), e=video.buffered.end(i); if(video.currentTime>=s && video.currentTime<=e) return e-video.currentTime; } } catch{} return 0; })();
      const stagnating = !video.paused && video.readyState>=2 && telem.stagnation>=3; // already tracked every second
      if(stagnating && !stallActive){
        stallActive=true; stallStartTs=Date.now(); stallStartCT=video.currentTime; stallStartDrift=driftNow;
        telemetry && telemetry('client-stall-start',{ ct:Number(stallStartCT.toFixed(2)), drift:Number(stallStartDrift.toFixed(2)), rs:video.readyState, ns:video.networkState, buf:bufAhead.toFixed(2) });
    clientLog('perf','stall-start',{ ct:Number(stallStartCT.toFixed(2)), drift:Number(stallStartDrift.toFixed(2)), rs:video.readyState, ns:video.networkState, buf:bufAhead });
      } else if(!stagnating && stallActive){
        const durMs = Date.now()-stallStartTs; const lost = video.currentTime - stallStartCT; const driftEnd=currentDrift();
        telemetry && telemetry('client-stall-end',{ ct:Number(video.currentTime.toFixed(2)), durMs, lostSec:Number(lost.toFixed(2)), driftStart:Number(stallStartDrift.toFixed(2)), driftEnd:Number(driftEnd.toFixed(2)), rsEnd:video.readyState, nsEnd:video.networkState, bufEnd:bufAhead.toFixed(2) });
    clientLog('perf','stall-end',{ ct:Number(video.currentTime.toFixed(2)), durMs, lostSec:Number(lost.toFixed(2)), driftStart:Number(stallStartDrift.toFixed(2)), driftEnd:Number(driftEnd.toFixed(2)), bufEnd:bufAhead });
        stallActive=false;
      }
    }, 1000);
    video.addEventListener('loadedmetadata', () => {
      if (pendingTarget != null) { suppress = true; video.currentTime = pendingTarget; pendingTarget = null; setTimeout(() => suppress = false, 60); }
      if (!isAdmin && lastState && !lastState.paused && !awaitExplicitPlay) ensureViewerPlaying();
      if(!subsEnabled) scheduleAutoSubs((WP_CLIENT_CONFIG?.subtitles?.autoEnableRetriesMetadata)||3);
      telemetry('media.loadedmeta.viewer', {t: video.currentTime, dur: video.duration||0});
      try {
        const attempt = window.__videoLoadAttempts||1;
        if(ws && ws.readyState===1){ ws.send(JSON.stringify({ type:'media-loaded', rev: lastRev, attempt })); }
      } catch{}
      if(video.__loadWatchTimer){ clearTimeout(video.__loadWatchTimer); video.__loadWatchTimer=null; }
      // Post-metadata drift refine for hot join (single adjustment window before playback)
      if(!isAdmin && initialSync){
        try {
          if(lastState){
            let adjusted = lastState.t;
            if(!lastState.paused){ let d=(Date.now()-lastState.ts-latencyMs)/1000; if(d<0)d=0; adjusted += d; }
            let diff = video.currentTime - adjusted;
            if(Math.abs(diff) > 0.4){ suppress=true; video.currentTime = adjusted; setTimeout(()=>suppress=false,60); telemetry && telemetry('join.sync.adjust',{ ct:Number(video.currentTime.toFixed(2)), target:Number(adjusted.toFixed(2)), diff:Number(diff.toFixed(2)) }); }
          }
        } catch{}
      }
    });
    video.addEventListener('play', ()=> {
      telemetry('media.play.auto');
      // If this was a hot join and user isn't muted & not sidecar, attempt delayed unmute (autoplay policies)
      try {
        if(!isAdmin && !sidecarMode && video.muted && !userMuted && !video.__delayedUnmuteDone){
          video.__delayedUnmuteDone=true; setTimeout(()=>{ if(!sidecarMode && video.muted && !userMuted){ video.muted=false; telemetry && telemetry('viewer.autoplay.unmute',{ ct:Number(video.currentTime.toFixed(2)) }); } }, 260);
        }
      } catch{}
    });
    video.addEventListener('pause', ()=> telemetry('media.pause.auto'));
    // Media load failure / timeout instrumentation
    function armLoadWatch(rev, path){
      if(video.__loadWatchTimer){ clearTimeout(video.__loadWatchTimer); }
      video.__loadWatchTimer = setTimeout(()=>{
        try {
          const rs = video.readyState; const ns = video.networkState; const haveMeta = rs>=1; const src = video.currentSrc || video.src;
          telemetry && telemetry('media.load.timeout',{ rev, path, rs, ns, haveMeta, src: (!!src), attempts: window.__videoLoadAttempts||0 });
          if(!haveMeta){ console.warn('[media] metadata not loaded within timeout', {rev, path, rs, ns}); }
        } catch{}
      }, (WP_CLIENT_CONFIG?.media?.loadMetadataTimeoutMs)||5200);
    }
    // Removed separate collapse/expand buttons; control bar button handles it
    let chatAutoScroll = true;
    function esc(t) { return t.replace(/[&<>"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[c])); }
    function fmtTime(ts) { const d = new Date(ts); return '[' + d.getHours().toString().padStart(2, '0') + ':' + d.getMinutes().toString().padStart(2, '0') + ']'; }
    // Colors loaded from server to avoid duplication with backend constants
    let CHAR_COLOR_HEX = {};
    let CHAR_PALETTE = [];
    let colorsLoaded = false;
    let currentSelf = null; // early declaration for rename button refresh
    function applyColorMapToChat() {
      if (!colorsLoaded) return;
      const __t0 = performance.now();
      document.querySelectorAll('.chat-line').forEach(div => {
        const colorKey = div.dataset && div.dataset.color;
        if (!colorKey) return;
        const hex = CHAR_COLOR_HEX[colorKey];
        if (!hex) return;
        const nameSpan = div.querySelector('.name');
        if (nameSpan) nameSpan.style.color = hex;
        // Upgrade generic dot to avatar if not already present
        if (!div.querySelector('.chat-avatar')) {
          const dot = div.querySelector('.icon');
          if (dot) { dot.outerHTML = `<span class="chat-avatar"><img src="${spriteImg(colorKey)}" alt="${colorKey}"></span>`; }
        }
      });
  const dt = performance.now()-__t0; if (window.DEBUG_UI && dt>8) console.log('[perf] applyColorMapToChat', dt.toFixed(2)+'ms');
    }
    (async () => {
      try {
        const r = await fetch('/api/colors');
        if (r.ok) {
          const j = await r.json();
          if (j && j.hex) { Object.assign(CHAR_COLOR_HEX, j.hex); }
          if (j && j.palette) CHAR_PALETTE = j.palette;
          colorsLoaded = true;
          applyColorMapToChat();
          // Refresh presence header & rename button if already populated
          if (lastPresenceUsers) setUsers(lastPresenceUsers);
          refreshNameButton();
        }
      } catch (e) { console.warn('color fetch failed', e); }
    })();
    function spriteImg(name) { return `/media/sprites/square_${name}.png`; }
    function appendChat(msg) {
      const t0 = performance.now();
      const div = document.createElement('div'); div.className = 'chat-line';
      div.dataset.color = msg.color || '';
      const hex = (msg.color && CHAR_COLOR_HEX[msg.color]) || '#9e9e9e';
      const haveHex = !!(msg.color && CHAR_COLOR_HEX[msg.color]);
      const avatar = (msg.color
        ? (haveHex
            ? `<span class="chat-avatar"><img src="${spriteImg(msg.color)}" alt="${esc(msg.color)}"></span>`
            : `<span class="icon" style="color:${hex}">●</span>`)
        : `<span class="icon" style="color:${hex}">●</span>`);
      div.innerHTML = `<span class="time">${fmtTime(msg.ts)}</span> ${avatar}<span class="name" style="color:${hex}">${esc(msg.name)}</span>: <span class="msg">${esc(msg.text)}</span>`;
      chatMessages.appendChild(div);
      if (chatAutoScroll) chatMessages.scrollTop = chatMessages.scrollHeight;
      if (colorsLoaded && !haveHex) applyColorMapToChat();
  const dt = performance.now()-t0; if (window.DEBUG_UI && dt>6) console.log('[perf] appendChat', dt.toFixed(2)+'ms');
    }
    // Removed separate admin CC panel – admin now uses unified control bar.
    function appendSystem(msg) {
      const div = document.createElement('div'); div.className = 'chat-line';
      div.style.opacity = '.8'; div.style.fontStyle = 'italic';
      div.innerHTML = `<span class="time">${fmtTime(msg.ts)}</span> <span class="msg">${esc(msg.text)}</span>`;
      chatMessages.appendChild(div);
      if (chatAutoScroll) chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    function appendSelfNotice(id, name, color) {
      const ts = Date.now();
      const hex = color && CHAR_COLOR_HEX[color] || '#9e9e9e';
      const haveHex = !!(color && CHAR_COLOR_HEX[color]);
      const avatar = color ? (haveHex ? `<span class="chat-avatar"><img src="${spriteImg(color)}" alt="${esc(color)}"></span>` : `<span class="icon" style="color:${hex}">●</span>`) : `<span class="icon" style="color:${hex}">●</span>`;
      const div = document.createElement('div'); div.className = 'chat-line'; div.style.fontStyle = 'italic'; div.style.opacity = '.8';
      div.dataset.color = color || '';
      div.innerHTML = `<span class="time">${fmtTime(ts)}</span> ${avatar} Connected as <span class="name" style="color:${hex}">${esc(name)}</span>`;
      chatMessages.appendChild(div);
      if (chatAutoScroll) chatMessages.scrollTop = chatMessages.scrollHeight;
      if (colorsLoaded && !haveHex) applyColorMapToChat();
    }
    chatMessages.addEventListener('scroll', () => {
      const atBottom = (chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight) < 40;
      chatAutoScroll = atBottom;
    });
    let lastPresenceUsers = null;
    function setUsers(list) {
      lastPresenceUsers = list;
      chatUsersEl.innerHTML = '';
      if (!list || !list.length) { return; }
      const countSpan = document.createElement('span');
      countSpan.className = 'user-count';
      countSpan.textContent = '(' + list.length + ')';
      chatUsersEl.appendChild(countSpan);
      list.forEach(u => {
        if (u.color) {
          const img = document.createElement('img');
          img.src = spriteImg(u.color);
          img.alt = u.name || u.color;
          img.title = (u.name ? u.name + ' • ' : '') + u.color;
          img.className = 'user-sprite';
          chatUsersEl.appendChild(img);
        } else {
          const dot = document.createElement('span');
          dot.textContent = '●';
          dot.className = 'gray-mini-dot';
          chatUsersEl.appendChild(dot);
        }
      });
    }
  chatForm.addEventListener('submit', e => { e.preventDefault(); const t = chatInput.value.trim(); if (!t || !ws || ws.readyState !== 1) return; ws.send(JSON.stringify({ type: 'chat', text: t })); chatInput.value = ''; });
    function collapseChat() { chatPanel.classList.add('collapsed'); localStorage.chatCollapsed = '1'; }
    function expandChat() { chatPanel.classList.remove('collapsed'); localStorage.chatCollapsed = '0'; setTimeout(() => { chatMessages.scrollTop = chatMessages.scrollHeight; chatAutoScroll = true; }, 50); }
    if (localStorage.chatCollapsed === '1') { collapseChat(); }
    updateFloatingVisibility();
    // Chat toggle after initial state
    setTimeout(() => { const btn = document.getElementById('customCtr')?.querySelector('button:last-child'); updateChatToggle(); }, 0);
  // (Removed earlier duplicate wsMessage; single definition later.)

    // Rename popup UI
    // currentSelf already declared earlier
    const colorHexMap = CHAR_COLOR_HEX;
    const renameBtn = document.getElementById('nameBtn');
    renameBtn.onmouseenter = () => renameBtn.style.background = '#25313b'; renameBtn.onmouseleave = () => renameBtn.style.background = '#1e2730';
    function refreshNameButton() { if (currentSelf) { const hex = currentSelf.color ? colorHexMap[currentSelf.color] : '#9e9e9e'; renameBtn.innerHTML = `<span style="color:${hex};font-weight:600">● ${(currentSelf.name || 'name')}</span>`; } }
    function openRename() {
      if (!currentSelf) return;
      const wrap = document.createElement('div');
  wrap.className = 'rename-overlay';
      const box = document.createElement('div');
  box.className = 'rename-box';
  box.innerHTML = '<h3 class="rename-title">Choose a Character</h3>';
  const form = document.createElement('form'); form.className='rename-form-grid';
  // Name input (will be placed on bottom row with action buttons; create early for logic reuse)
  const nameInput = document.createElement('input');
  nameInput.type = 'text'; nameInput.maxLength = 40; nameInput.placeholder = 'Custom name (optional)';
  nameInput.className = 'name-input';
      const palette = (CHAR_PALETTE.length ? CHAR_PALETTE : ['frieren', 'himmel', 'heiter', 'eisen', 'fern', 'stark', 'sein', 'übel']);
      palette.forEach(c => {
  const id = 'c_' + c; const label = document.createElement('label'); label.className = 'char-choice';
  label.innerHTML = `<input type=\"radio\" name=\"color\" value=\"${c}\" id=\"${id}\" style=\"accent-color:${colorHexMap[c]}\" ${(currentSelf.color === c) ? 'checked' : ''}> <img src="${spriteImg(c)}" style="width:18px;height:18px;object-fit:contain;image-rendering:crisp-edges;"> <span style=\"color:${colorHexMap[c]};font-weight:600\">${c}</span>`;
        form.appendChild(label);
      });
      // Initialize name input with current display name
      try { nameInput.value = currentSelf.name || (currentSelf.color || ''); } catch {}
      // Update name field when radio selection changes if user hasn't edited manually yet
      let namePristine = true;
      nameInput.addEventListener('input', ()=>{ namePristine = false; });
      form.addEventListener('change', e => {
        if (e.target && e.target.name === 'color' && namePristine) {
          const val = e.target.value;
            nameInput.value = val;
        }
      });
  const actions = document.createElement('div');
  actions.className = 'actions-row';
  actions.appendChild(nameInput);
  const btnWrap = document.createElement('div'); btnWrap.className='btn-row';
  const cancel = document.createElement('button'); cancel.type = 'button'; cancel.textContent = 'Cancel'; cancel.className = 'btn btn-outline';
  const save = document.createElement('button'); save.type = 'submit'; save.textContent = 'Save'; save.className = 'btn btn-primary';
  btnWrap.appendChild(cancel); btnWrap.appendChild(save); actions.appendChild(btnWrap);
  form.appendChild(actions); box.appendChild(form); wrap.appendChild(box); document.body.appendChild(wrap);
  cancel.onclick = () => { if (window.DEBUG_UI) console.log('[rename-popup] cancel'); wrap.remove(); };
  save.addEventListener('click', () => { if (window.DEBUG_UI) console.log('[rename-popup] save click (pre-submit)'); });
  form.addEventListener('submit', e => { e.preventDefault(); if (window.DEBUG_UI) console.log('[rename-popup] submit'); const fd = new FormData(form); const color = fd.get('color'); const name = nameInput.value.trim(); if (window.DEBUG_UI) console.log('[rename-popup] selected', color, 'name', name); if (color && ws.readyState === 1) { if (window.DEBUG_UI) console.log('[rename-popup] sending rename'); ws.send(JSON.stringify({ type: 'rename', color, name })); } else { if (window.DEBUG_UI) console.log('[rename-popup] not sent (missing color or ws not open)'); } wrap.remove(); });
    }
    renameBtn.onclick = () => openRename();
  // (duplicate onclose assignment removed – handled in createSocket)
  function send(type, extra = {}) {
    if (!isAdmin) return;
    if (!ws || ws.readyState !== 1) return;
    const payload = { type, key: ADMIN_KEY, t: video.currentTime, ...extra };
    log('send', payload);
    try { ws.send(JSON.stringify(payload)); } catch {}
  }
    function schedulePing() { lastPingSent = Date.now(); if (ws.readyState === 1) { ws.send(JSON.stringify({ type: 'ping' })); } }
    function pingLoop(){
      if (!ws) return;
      if (ws.readyState === 1) schedulePing();
  setTimeout(pingLoop, (WP_CLIENT_CONFIG?.network?.pingIntervalMs)||5000);
    }
  function wsMessage(ev){
    try {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'state') { log('state', msg.data); applyState(msg.data); }
      else if (msg.type === 'toast') { if (msg.text === 'Pause requested' && !isAdmin) {} else { showToast(msg.text || ''); } }
  else if (msg.type === 'pong') { const now = Date.now(); if (lastPingSent) { const rtt = now - lastPingSent; latencyMs = Math.max(0, Math.round(rtt/2)); if(VERBOSE||window.DEBUG_UI) log('pong rtt', rtt, 'lat', latencyMs); } }
      else if (msg.type === 'presence') { setUsers(msg.users); }
      else if (msg.type === 'chat-history') { msg.items.forEach(it => { if (it.type === 'chat') { appendChat(it); pushFloatingChat(it); } else if (it.type === 'system') appendSystem(it); }); }
      else if (msg.type === 'chat') { appendChat(msg); pushFloatingChat(msg); }
      else if (msg.type === 'system') { appendSystem(msg); }
      else if (msg.type === 'self') { appendSelfNotice(msg.id, msg.name, msg.color); currentSelf = msg; refreshNameButton(); }
      else if (msg.type === 'rename-result') { if (!msg.ok) { if (msg.reason === 'in-use') showToast('Color in use'); else if (msg.reason === 'unchanged') showToast('No change'); else showToast('Rename failed'); } else showToast('Name updated'); }
      else if (msg.type === 'seek-gate') { if(!isAdmin){ pendingSeekGate = { gateId: msg.gateId, targetT: msg.t, sentReady:false }; telemetry('seek.gate.start',{ gateId: msg.gateId, t: msg.t, rev: msg.rev }); try { video.pause(); } catch{} } }
    } catch(e){ log('bad msg', e); }
  }
    // Admin-originated events
    // Admin-originated playback events propagate currentTime via payload.t set inside send()
  // Always broadcast play/pause for admin; suppression only applies to seek noise
  video.addEventListener('play', () => { if (isAdmin) { telemetry('media.play.broadcast'); send('play'); } });
  video.addEventListener('pause', () => { if (isAdmin) { telemetry('media.pause.broadcast'); send('pause'); } });
    // Admin initial play stall instrumentation
    if(isAdmin){
      let __firstAdminPlayFired=false; let __playStartWall=0; let __playStartCT=0;
      video.addEventListener('play', ()=>{
        if(!__firstAdminPlayFired){
          __firstAdminPlayFired=true; __playStartWall=performance.now(); __playStartCT=video.currentTime;
          telemetry && telemetry('admin.play.initial.start',{ ct:Number(__playStartCT.toFixed(2)) });
        }
      });
      video.addEventListener('playing', ()=>{
        if(__playStartWall){
          const dur = performance.now()-__playStartWall;
          telemetry && telemetry('admin.play.initial.stable',{ ms:Math.round(dur), ct:Number(video.currentTime.toFixed(2)) });
          __playStartWall=0;
        }
      });
    }
    let lastSeekSent = 0; let lastSeekTarget = null; video.addEventListener('seeked', () => {
      if (!isAdmin) return;
      const now = Date.now();
      try { video.pause(); } catch{}
      const tgt = Number(video.currentTime.toFixed(2));
      if (lastSeekTarget!=null && (now - lastSeekSent) < 800 && Math.abs(tgt - lastSeekTarget) < 0.25) {
        telemetry('seek.duplicate.suppressed',{ prevT:lastSeekTarget, newT:tgt, delta:Number((tgt-lastSeekTarget).toFixed(3)) });
        return;
      }
      telemetry('seek.admin.initiate',{ t: tgt });
      send('seek', { paused: true });
  // Mark host pending gate until resume broadcast
  pendingHostSeekGate = true; telemetry && telemetry('seek.gate.host.start',{ t: tgt });
      lastSeekSent = now; lastSeekTarget = tgt;
    });
    // Removed periodic drift reapply & admin tick (sync only on admin actions & join)
    if(!isAdmin){
      // Large drift monitor: alert admin if >30s once per media revision
      setInterval(()=>{
        if(!lastState || lastState.paused) return;
        if(!video || !video.duration) return;
        const now = Date.now();
      // Suppress drift alert shortly after an admin seek so viewer can resync
      if(window.__lastSeekTs && (now - window.__lastSeekTs) < ((WP_CLIENT_CONFIG?.drift?.seekSuppressMs)||4000)) return;
        let target = lastState.t;
        if(!lastState.paused){
          let delta = (now - lastState.ts - latencyMs)/1000; if(delta<0) delta=0; target += delta;
        }
        const drift = video.currentTime - target;
        if(Math.abs(drift) > (WP_CLIENT_CONFIG?.drift?.alertThresholdSec||30) && lastState.rev!=null){
          if(window.__lastDriftAlertRev !== lastState.rev){
            window.__lastDriftAlertRev = lastState.rev;
            try { ws && ws.readyState===1 && ws.send(JSON.stringify({ type:'drift-alert', drift })); } catch{}
          }
        }
  // Also periodically report current position for admin status panel accuracy
  try { ws && ws.readyState===1 && ws.send(JSON.stringify({ type:'pos', t: video.currentTime })); } catch{}
  }, (WP_CLIENT_CONFIG?.drift?.checkIntervalMs)||5000);
    }
    // Extra logging around play/pause events
    video.addEventListener('timeupdate', () => { if (isAdmin && !video.paused && ws.readyState === 1) {/* light */ } });
    // Auto acquire admin key in dev mode
    if (ADMIN_KEY === 'auto') {
      fetch('/admin-key').then(r => r.json()).then(d => { if (d.key) { ADMIN_KEY = d.key; isAdmin = true; log('auto admin key acquired'); } });
    }
    // Admin file picker
    if (isAdmin && VERBOSE) {
      const panel = document.createElement('div');
      panel.style.cssText = 'position:fixed;right:6px;top:6px;max-height:60vh;overflow:auto;background:rgba(0,0,0,.65);padding:6px 8px;border-radius:6px;font:12px system-ui;z-index:20;';
      panel.textContent = 'loading files...';
      document.body.appendChild(panel);
      fetch('/api/files').then(r => r.json()).then(list => {
        panel.textContent = '';
        list.forEach(f => {
          const a = document.createElement('div');
          a.textContent = f; a.style.cursor = 'pointer'; a.style.padding = '2px 4px';
          a.onclick = () => { send('load', { path: f }); };
          a.onmouseenter = () => a.style.background = '#222';
          a.onmouseleave = () => a.style.background = 'transparent';
          panel.appendChild(a);
        });
        if (!list.length) panel.textContent = '(no files)';
      }).catch(e => panel.textContent = 'error listing files');
    }
    // Admin lightweight CC selector (even outside VERBOSE for parity)
    // Admin relies on native subtitles: when admin enables CC via browser's track UI (if exposed)
    // Toast utility
  function showToast(text) { if (!text) return; const t = document.createElement('div'); t.textContent = text; t.className = 'toast'; document.body.appendChild(t); requestAnimationFrame(() => t.style.opacity = '1'); const toastDur = (WP_CLIENT_CONFIG?.toast?.durationMs)||2200; const toastFade = (WP_CLIENT_CONFIG?.toast?.fadeMs)||400; setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), toastFade); }, toastDur); }

    // Floating chat overlay message push
    function pushFloatingChat(msg) {
      if (msg.type !== 'chat') return;
      if (floatChat.style.display === 'none') return; // not visible; skip
      const hex = (msg.color && CHAR_COLOR_HEX[msg.color]) || '#ddd';
      const haveHex = !!(msg.color && CHAR_COLOR_HEX[msg.color]);
      const div = document.createElement('div');
      div.dataset.color = msg.color || '';
      // Tighter shadow, left-justified; slight padding for consistent start edge
      // Bigger font & thicker tight outline (multi-direction 1px offsets without large blur)
  div.className = 'float-line'; div.style.color = hex;
      let avatarHtml;
      if (msg.color) {
        avatarHtml = haveHex ? `<span class="chat-avatar" style="position:static;width:20px;height:20px;margin:0;background:#14181c;overflow:hidden;border-radius:4px;display:inline-flex;align-items:center;justify-content:center;"><img src="${spriteImg(msg.color)}" alt="${esc(msg.color)}" style="max-width:100%;max-height:100%;object-fit:contain;image-rendering:crisp-edges;"></span>` : `<span class="icon" style="color:${hex};font-size:10px;">●</span>`;
      } else {
        avatarHtml = `<span class="icon" style="color:${hex};font-size:10px;">●</span>`;
      }
      div.innerHTML = `${avatarHtml}<span class="name" style="color:${hex};font-weight:600;">${esc(msg.name)}</span><span class="msg" style="color:#fff;font-weight:400;">${esc(msg.text)}</span>`;
      floatChat.appendChild(div);
      requestAnimationFrame(() => { div.style.opacity = '1'; });
      // Limit count
      const MAX_FLOAT = (WP_CLIENT_CONFIG?.chat?.floating?.maxMessages)||12; while (floatChat.children.length > MAX_FLOAT) { floatChat.firstChild.remove(); }
  const LIFETIME = (WP_CLIENT_CONFIG?.chat?.floating?.lifetimeMs)||9000, FADE = (WP_CLIENT_CONFIG?.chat?.floating?.fadeMs)||1500; setTimeout(() => { div.style.opacity = '0'; }, LIFETIME - FADE); setTimeout(() => { try { div.remove(); } catch { } }, LIFETIME);
    }
    function applyColorMapToFloating() {
      document.querySelectorAll('#floatChat > div').forEach(div => {
        const c = div.dataset.color; if (!c) return; if (div.querySelector('img')) return; if (CHAR_COLOR_HEX[c]) {
          const hex = CHAR_COLOR_HEX[c];
          const icon = div.querySelector('.icon');
          if (icon) { icon.outerHTML = `<span class=chat-avatar style="position:static;width:20px;height:20px;margin:0;background:#14181c;overflow:hidden;border-radius:4px;display:inline-flex;align-items:center;justify-content:center;"><img src="${spriteImg(c)}" alt="${c}" style="max-width:100%;max-height:100%;object-fit:contain;image-rendering:crisp-edges;"></span>`; }
          const name = div.querySelector('.name'); if (name) name.style.color = hex;
        }
      });
    }
    // Wrap existing applyColorMapToChat to also upgrade floating messages
    const __origApplyColorMapToChat = applyColorMapToChat;
    applyColorMapToChat = function () { __origApplyColorMapToChat(); applyColorMapToFloating(); };
    updateFloatingVisibility();

    // Viewer spacebar -> pause request to admin
  document.addEventListener('keydown', e => { if (!isAdmin && (e.code === 'Space' || e.key === ' ')) { if (document.activeElement === video || document.activeElement === document.body) { e.preventDefault(); if (ws && ws.readyState === 1) { ws.send(JSON.stringify({ type: 'request', action: 'pause' })); showToast('Pause requested'); } } } });
  // Visibility handling: send a ping when returning to foreground to refresh lastSeen and avoid timeout
  document.addEventListener('visibilitychange', ()=>{ if (!document.hidden) { if (ws && ws.readyState===1) { ws.send(JSON.stringify({ type:'ping', vis:true })); } } });
    // Seek gate readiness polling (viewer only)
    setInterval(()=>{
      if(isAdmin) return;
      if(!pendingSeekGate || pendingSeekGate.sentReady) return;
      if(!lastState) return;
      if(!video.duration || video.duration<=0) return;
      // Only evaluate when paused
      if(!video.paused) return;
      const targetT = pendingSeekGate.targetT;
      // ensure near target
      if(Math.abs(video.currentTime - targetT) > 1.0) return;
      let ahead=0;
      try {
        for(let i=0;i<video.buffered.length;i++){
          const s=video.buffered.start(i), e=video.buffered.end(i);
            if(targetT >= s && targetT <= e){ ahead = e - targetT; break; }
        }
      } catch{}
      const dur = video.duration || 0;
      const needed = Math.min(Math.max(3, dur*0.02), 12); // min(max(3s,2%),12s)
      if(ahead >= needed || (dur && targetT > dur - 0.25)){
        try { if(ws && ws.readyState===1){ ws.send(JSON.stringify({ type:'seek-ready', gateId: pendingSeekGate.gateId })); pendingSeekGate.sentReady = true; telemetry('seek.gate.ready',{ gateId: pendingSeekGate.gateId, ahead: Number(ahead.toFixed(2)), needed: Number(needed.toFixed(2)) }); } } catch{}
      }
    }, 700);
    
  // Immediate socket connect (server already enforced access gate)
  createSocket();

  // Defer wrapping after initial script so that referenced functions exist.
  setTimeout(()=>{
    try {
      const toWrap = ['applyState','ensureViewerPlaying','createSocket','wsMessage','send','telemetry','clientLog','showToast','enableDefaultSubs','scheduleAutoSubs','layoutSubs','renderActiveCues','ensureSubTrack','openRename','openMediaPicker','forceHomeCleanup','applyColorMapToChat','appendChat','appendSystem','appendSelfNotice','fetchConnections','fetchDelivery'];
      for(const n of toWrap){
        try { if(typeof window[n]==='function' && !window['__wrapped_'+n]){ window[n] = __wrap(n, window[n]); window['__wrapped_'+n]=true; } } catch{}
      }
    } catch{}
  },0);

  // --- Hot join final drift & subtitle watchdog (appended) ---
    if(typeof window.__finalJoinAugmented === 'undefined'){
      window.__finalJoinAugmented = true;
      let __finalJoinDone = false;
      function __computeAuthTarget(){
        if(!lastState) return video.currentTime;
        let t = lastState.t; if(!lastState.paused){ let d=(Date.now()-lastState.ts - latencyMs)/1000; if(d<0)d=0; t+=d; }
        return t<0?0:t;
      }
      function __finalDriftCorrection(){
        if(__finalJoinDone || isAdmin || initialSync || !lastState) return;
        if(video.readyState < 2) return;
        const target = __computeAuthTarget();
        const diff = video.currentTime - target; const abs = Math.abs(diff);
        const thresh = (WP_CLIENT_CONFIG?.sync?.finalJoinDriftThreshold||0.25);
        if(abs>thresh){ try { suppress=true; video.currentTime = target; setTimeout(()=>suppress=false,40); telemetry && telemetry('join.sync.final',{ ct:Number(video.currentTime.toFixed(2)), target:Number(target.toFixed(2)), diff:Number(diff.toFixed(2)), rs:video.readyState }); } catch{} }
        else { telemetry && telemetry('join.sync.final.skip',{ ct:Number(video.currentTime.toFixed(2)), target:Number(target.toFixed(2)), diff:Number(diff.toFixed(2)) }); }
      }
      function __verifySubs(){
        if(isAdmin || __finalJoinDone) return;
        if(!subsEnabled){ if(!autoSubsAttempted){ scheduleAutoSubs(2); telemetry && telemetry('subs.verify.retryEnable'); } return; }
        try { if(subTrackEl && subTrackEl.track){ const cues=subTrackEl.track.cues; if((!cues || cues.length===0) && video.currentTime>3){ telemetry && telemetry('subs.verify.noCues',{ lang: currentLang||null }); const base=subTrackEl.src.split('?')[0]; const qp=new URLSearchParams(); qp.set('rev',(lastState?.rev||0)); qp.set('t',Date.now()); qp.set('lang', currentLang||'eng'); subTrackEl.src=base+'?'+qp.toString(); subTrackEl.track.mode='hidden'; setTimeout(()=>{ renderActiveCues(); },160); telemetry && telemetry('subs.verify.reload',{ lang: currentLang||null }); } } } catch{}
      }
      function scheduleFinalJoinCheck(){ if(__finalJoinDone || isAdmin) return; setTimeout(()=>{ if(__finalJoinDone) return; __finalDriftCorrection(); __verifySubs(); const target=__computeAuthTarget(); const diff=video.currentTime-target; const subsOk = subsEnabled && subTrackEl && subTrackEl.track && ((subTrackEl.track.cues||{}).length>0 || video.currentTime<5); if(Math.abs(diff) <= (WP_CLIENT_CONFIG?.sync?.finalJoinDriftThreshold||0.25) && subsOk){ __finalJoinDone=true; telemetry && telemetry('join.sync.final.done',{ diff:Number(diff.toFixed(2)), subs:subsOk }); } else { setTimeout(()=>{ if(__finalJoinDone) return; __finalDriftCorrection(); __verifySubs(); const t2=__computeAuthTarget(); const d2=video.currentTime-t2; __finalJoinDone=true; telemetry && telemetry('join.sync.final.done2',{ diff:Number(d2.toFixed(2)), subs:(subsEnabled && subTrackEl && subTrackEl.track)||false }); }, 1200); } },650); }
      // Attach lightweight listeners instead of editing earlier handlers
      video.addEventListener('loadedmetadata', ()=>{ if(!isAdmin) scheduleFinalJoinCheck(); });
      video.addEventListener('play', ()=>{ if(!isAdmin) scheduleFinalJoinCheck(); });
    }
  </script>
</body>

</html>
<!-- Telemetry: global error hooks -->
<script>
  (function(){
    function safeTelemetry(ev,data){ try { if(window.telemetry) window.telemetry(ev,data); } catch{} }
    window.addEventListener('error', function(e){
      safeTelemetry('error.window',{ msg: e.message, src: e.filename, line: e.lineno, col: e.colno, stack: (e.error && e.error.stack)||null });
    });
    window.addEventListener('unhandledrejection', function(e){
      let info={};
      try {
        if(e.reason){
          if(typeof e.reason==='string') info.msg=e.reason;
          else if(e.reason && e.reason.message) info.msg=e.reason.message;
          if(e.reason && e.reason.stack) info.stack=e.reason.stack;
          if(e.reason && e.reason.name) info.name=e.reason.name;
        }
      } catch{}
      safeTelemetry('error.unhandledrejection', info);
    });
  })();
</script>